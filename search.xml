<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 面向对象的五大原则]]></title>
    <url>%2F2018%2F12%2F05%2FJava-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[目录 面向对象五大原则： 单一职责原则（Single-Resposibility Principle） 开放封闭原则（Open-Closed principle） 里氏替换原则（Liskov-Substituion Principle） 依赖倒置原则（Dependecy-Inversion Principle） ISP 接口隔离原则(Interface-Segregation Principle) 面向对象五大原则：单一职责原则（Single-Resposibility Principle）一个类应该仅有一个引起它变化的原因职员类例子： 比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要ifelse判断是哪种情况，从类结构上来说将会十分臃肿，并且上述三种的职员类型，不论哪一种发生需求变化，都会改变职员类！这个是大家所不愿意看到的！ 开放封闭原则（Open-Closed principle）对扩展是开放的，对更改是封闭的！变化来临时，如果不必改动软件实体裁的源代码，就能扩充它的行为，那么这个软件实体设计就是满足开放封闭原则的。如果说我们预测到某种变化，或者某种变化发生了，我们应当创建抽象类来隔离以后发生的同类变化。 里氏替换原则（Liskov-Substituion Principle）子类可以替换父类并且出现在父类能够出现的任何地方,贯彻GOF倡导的面向接口编程在这个原则中父类应尽可能使用接口或者抽象类来实现！子类通过实现了父类接口，能够替父类的使用地方！通过这个原则，我们客户端在使用父类接口的时候，通过子类实现！意思就是说我们依赖父类接口，在客户端声明一个父类接口，通过其子类来实现这个时候就要求子类必须能够替换父类所出现的任何地方，这样做的好处就是，在根据新要求扩展父类接口的新子类的时候而不影响当前客户端的使用！ 依赖倒置原则（Dependecy-Inversion Principle）传统的结构化编程中，最上层的模块通常都要依赖下面的子模块来实现，也称为高层依赖低层！所以DIP原则就是要逆转这种依赖关系，让高层模块不要依赖低层模块，所以称之为依赖倒置原则！ ISP 接口隔离原则(Interface-Segregation Principle)使用多个专门的接口比使用单个接口要好的多！这个我有体会，在我实际编程中，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！]]></content>
      <categories>
        <category>Java 基本功</category>
      </categories>
      <tags>
        <tag>Java 面向对象的五大原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象的特征]]></title>
    <url>%2F2018%2F12%2F05%2FJava-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[目录 封装 抽象 继承 多态 面向对象编程有三大特性：封装、继承、多态。 多态的实现 实现条件 实现形式 基于继承实现的多态 基于接口实现的多态 #面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。 封装封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。 抽象抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：1234class Person&#123; String name; int age; &#125;人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。## 继承在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 多态多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。例如，下面代码中的UserDao是一个接口，它定义引用变量userDao指向的实例对象由daofactory.getDao()在执行的时候返回，有时候指向的是UserJdbcDao这个实现，有时候指向的是UserHibernateDao这个实现，这样，不用修改源代码，就可以改变userDao指向的具体类实现，从而导致userDao.insertUser()方法调用的具体代码也随之改变，即有时候调用的是UserJdbcDao的insertUser方法，有时候调用的是UserHibernateDao的insertUser方法：12UserDao userDao = daofactory.getDao(); userDao.insertUser(user);# 面向对象编程有三大特性：封装、继承、多态。封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：酒 a = 剑南春酒 b = 五粮液酒 c = 酒鬼酒…这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：JNC a = new JNC();对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？Wine a = new JNC();在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了—1。123456789101112131415161718192021222324252627282930313233343536373839404142public class TestWine &#123; public static void main(String[] args) &#123; Wine a = new JNC(); a.fun1(); Wine b = new Wine(); b.fun1(); JNC c = new JNC(); c.fun1(); &#125; public static class Wine &#123; public void fun1()&#123; System.out.println("Wine 的Fun....."); fun2(); &#125; public void fun2()&#123; System.out.println("Wine 的Fun2..."); &#125; &#125; public static class JNC extends Wine&#123; /** * @desc 子类重载父类方法 * 父类中不存在该方法，向上转型后，父类是不能引用该方法的 * @param a * @return void */ public void fun1(String a)&#123; System.out.println("JNC 的 Fun1..."); fun2(); &#125; /** * 子类重写父类方法 * 指向子类的父类引用调用fun2时，必定是调用该方法 */ public void fun2()&#123; System.out.println("JNC 的Fun2..."); &#125; &#125;&#125;运行结果：Wine 的Fun…..JNC 的Fun2…Wine 的Fun…..Wine 的Fun2…Wine 的Fun…..JNC 的Fun2…从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。所以对于多态我们可以总结如下：指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。# 多态的实现## 实现条件继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。Java实现多态有三个必要条件：继承、重写、向上转型。1. 继承：在多态中必须存在有继承关系的子类和父类。2. 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。3. 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。## 实现形式在Java中有两种形式可以实现多态。继承和接口。#### 基于继承实现的多态基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class TestWine2 &#123; public static void main(String[] args) &#123; //定义父类数组 Wine[] wines = new Wine[2]; //定义两个子类 JNC jnc = new JNC(); JGJ jgj = new JGJ(); Wine wine=new Wine(); //父类引用子类对象 wines[0] = jnc; wines[1] = jgj; for(int i = 0 ; i &lt; 2 ; i++)&#123; System.out.println(wines[i].toString() + "--" + wines[i].drink()); &#125; System.out.println("-------------------------------"); System.out.println(jnc.toString() + "--" + jnc.drink()); System.out.println(jgj.toString() + "--" + jgj.drink()); &#125; public static class Wine &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Wine()&#123; &#125; public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return null; &#125; &#125; public static class JNC extends Wine&#123; public JNC()&#123; setName("JNC"); &#125; /** * 重写父类方法，实现多态 */ public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return "Wine : " + getName(); &#125; &#125; public static class JGJ extends Wine&#123; public JGJ()&#123; setName("JGJ"); &#125; /** * 重写父类方法，实现多态 */ public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return "Wine : " + getName(); &#125; &#125;&#125; 在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。 我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：123Object o = new JGJ();System.out.println(o.toString()); 输出的结果是Wine : JGJ。 Object、Wine、JGJ三者继承链关系是：JGJ—&gt;Wine—&gt;Object。所以我们可以这样说：当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用。但是注意如果这样写：123Object o = new Wine();System.out.println(o.toString()); 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。 所以基于继承实现的多态可以总结如下：对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。 如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。 基于接口实现的多态继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。 继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。]]></content>
      <categories>
        <category>Java 基本功</category>
      </categories>
      <tags>
        <tag>Java 面向对象的特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAop 理论]]></title>
    <url>%2F2018%2F12%2F04%2FSpringAop-%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[目录 什么是AOP AOP使用场景 AOP相关概念 Spring AOP组件 如何使用Spring AOP Spring AOP代理对象的生成 什么是AOPAOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。” 实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。 AOP使用场景AOP用来封装横切关注点，具体可以在下面的场景中使用: Authentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 AOP相关概念方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用spring的 Advisor或拦截器实现。 连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。 通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice 切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上 引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口 目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。 Spring AOP组件下面这种类图列出了Spring中主要的AOP组件 如何使用Spring AOP可以通过配置文件或者编程的方式来使用Spring AOP 配置可以通过xml文件来进行，大概有四种方式： 配置ProxyFactoryBean，显式地设置advisors, advice, target等 配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象 通过aop:config来配置 通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点 也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象 Spring AOP代理对象的生成Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关代码：123456789101112131415/** * &lt;ol&gt; * &lt;li&gt;获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false) * &lt;li&gt;检查上面得到的接口中有没有定义 equals或者hashcode的接口 * &lt;li&gt;调用Proxy.newProxyInstance创建代理对象 * &lt;/ol&gt; */public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Creating JDK dynamic proxy: target source is " +this.advised.getTargetSource()); &#125; Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(this.advised); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 下面的问题是，代理对象生成了，那切面是如何织入的？ 我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下Spring AOP是如何织入切面的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273publicObject invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; MethodInvocation invocation = null; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Class targetClass = null; Object target = null; try &#123; //eqauls()方法，具目标对象未实现此方法 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method))&#123; return (equals(args[0])? Boolean.TRUE : Boolean.FALSE); &#125; //hashCode()方法，具目标对象未实现此方法 if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method))&#123; return newInteger(hashCode()); &#125; //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知 if (!this.advised.opaque &amp;&amp;method.getDeclaringClass().isInterface() &amp;&amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123; // Service invocations onProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args); &#125; Object retVal = null; if (this.advised.exposeProxy) &#123; // Make invocation available ifnecessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; //获得目标对象的类 target = targetSource.getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; //获取可以应用到此方法上的Interceptor列表 List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass); //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args) if (chain.isEmpty()) &#123; retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args); &#125; else &#123; //创建MethodInvocation invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed(); &#125; // Massage return value if necessary. if (retVal != null &amp;&amp; retVal == target &amp;&amp;method.getReturnType().isInstance(proxy) &amp;&amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123; // Special case: it returned"this" and the return type of the method // is type-compatible. Notethat we can't help if the target sets // a reference to itself inanother returned object. retVal = proxy; &#125; return retVal; &#125; finally &#123; if (target != null &amp;&amp; !targetSource.isStatic()) &#123; // Must have come fromTargetSource. targetSource.releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 主流程可以简述为：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,则应用通知,并执行joinpoint; 如果没有,则直接反射执行joinpoint。而这里的关键是通知链是如何获取的以及它又是如何执行的，下面逐一分析下。12345678910public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123; MethodCacheKeycacheKey = new MethodCacheKey(method); List&lt;Object&gt;cached = this.methodCache.get(cacheKey); if(cached == null) &#123; cached= this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice( this,method, targetClass); this.methodCache.put(cacheKey,cached); &#125; returncached;&#125; 可以看到实际的获取工作其实是由AdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice()这个方法来完成的，获取到的结果会被缓存。 下面来分析下这个方法的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor, * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断 * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回. */publicList getInterceptorsAndDynamicInterceptionAdvice(Advised config, Methodmethod, Class targetClass) &#123; // This is somewhat tricky... we have to process introductions first, // but we need to preserve order in the ultimate list. List interceptorList = new ArrayList(config.getAdvisors().length); //查看是否包含IntroductionAdvisor boolean hasIntroductions = hasMatchingIntroductions(config,targetClass); //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); Advisor[] advisors = config.getAdvisors(); for (int i = 0; i &lt;advisors.length; i++) &#123; Advisor advisor = advisors[i]; if (advisor instanceof PointcutAdvisor) &#123; // Add it conditionally. PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor; if(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123; //TODO: 这个地方这两个方法的位置可以互换下 //将Advisor转化成Interceptor MethodInterceptor[]interceptors = registry.getInterceptors(advisor); //检查当前advisor的pointcut是否可以匹配当前方法 MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher(); if (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) &#123; if(mm.isRuntime()) &#123; // Creating a newobject instance in the getInterceptors() method // isn't a problemas we normally cache created chains. for (intj = 0; j &lt; interceptors.length; j++) &#123; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptors[j],mm)); &#125; &#125; else &#123; interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; &#125; &#125; else if (advisor instanceof IntroductionAdvisor)&#123; IntroductionAdvisor ia =(IntroductionAdvisor) advisor; if(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123; Interceptor[] interceptors= registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; else &#123; Interceptor[] interceptors =registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; return interceptorList;&#125; 这个方法执行完成后，Advised中配置能够应用到连接点或者目标类的Advisor全部被转化成了MethodInterceptor. 接下来我们再看下得到的拦截器链是怎么起作用的。1234567if (chain.isEmpty()) &#123; retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);&#125; else &#123; //创建MethodInvocation invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed();&#125; 从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建MethodInvocation，调用其proceed方法，触发拦截器链的执行，来看下具体代码123456789101112131415161718192021222324252627282930313233public Object proceed() throws Throwable &#123; // We start with an index of -1and increment early. if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()- 1) &#123; //如果Interceptor执行完了，则执行joinPoint return invokeJoinpoint(); &#125; Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); //如果要动态匹配joinPoint if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)&#123; // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice; //动态匹配：运行时参数是否满足匹配条件 if (dm.methodMatcher.matches(this.method, this.targetClass,this.arguments)) &#123; //执行当前Intercetpor returndm.interceptor.invoke(this); &#125; else &#123; //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor return proceed(); &#125; &#125; else &#123; // It's an interceptor, so we just invoke it: The pointcutwill have // been evaluated statically before this object was constructed. //执行当前Intercetpor return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125;]]></content>
      <categories>
        <category>Java 框架</category>
      </categories>
      <tags>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 工作原理]]></title>
    <url>%2F2018%2F12%2F04%2FSpringMVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[目录 SpringMVC的工作原理图： SpringMVC流程 组件说明 组件： SpringMVC的工作原理图： SpringMVC流程 用户发送请求至前端控制器DispatcherServlet。 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet调用HandlerAdapter处理器适配器。 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 Controller执行完成返回ModelAndView。 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ViewReslover解析后返回具体View。 DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应用户。 组件说明以下组件通常使用框架提供实现： DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。 ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。 组件：1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供作用：根据请求的url查找HandlerHandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 3、处理器适配器HandlerAdapter作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 4、处理器Handler(需要工程师开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行HandlerHandler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。 5、视图解析器View resolver(不需要工程师开发),由框架提供作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。 6、视图View(需要工程师开发jsp…)View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）]]></content>
      <categories>
        <category>Java 框架</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程]]></title>
    <url>%2F2018%2F12%2F04%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录 多线程的基本概念 什么是进程 多进程有什么作用？ 什么是线程 多线程有什么作用？ java 程序的运行原理？ 线程生命周期 线程的调度与控制 线程优先级 sleep 停止一个线程 yield join synchronized 死锁 守护线程 Timer.schedule() 多线程的基本概念线程指进程中的一个执行场景，也就是执行流程，那么进程和线程有什么区别呢？ 每个进程是一个应用程序，都有独立的内存空间 同一个进程中的线程共享其进程中的内存和资源（共享的内存是堆内存和方法区内存，栈内存不共享，每个线程有自己的。） 什么是进程一个进程对应一个应用程序。例如：在 windows 操作系统启动 Word 就表示启动了一个进程。在 java 的开发环境下启动 JVM，就表示启动了一个进程。现代的计算机都是支持多进程的，在同一个操作系统中，可以同时启动多个进程。 多进程有什么作用？单进程计算机只能做一件事情。玩电脑，一边玩游戏（游戏进程）一边听音乐（音乐进程）。对于单核计算机来讲，在同一个时间点上，游戏进程和音乐进程是同时在运行吗？不是。因为计算机的 CPU 只能在某个时间点上做一件事。由于计算机将在“游戏进程”和“音乐进程”之间频繁的切换执行，切换速度极高，人类感觉游戏和音乐在同时进行。多进程的作用不是提高执行速度，而是提高 CPU 的使用率。进程和进程之间的内存是独立的。 什么是线程线程是一个进程中的执行场景。一个进程可以启动多个线程。 多线程有什么作用？多线程不是为了提高执行速度，而是提高应用程序的使用率。线程和线程共享“堆内存和方法区内存”，栈内存是独立的，一个线程一个栈。可以给现实世界中的人类一种错觉：感觉多个线程在同时并发执行。 java 程序的运行原理？java 命令会启动 java 虚拟机，启动 JVM，等于启动了一个应用程序，表示启动了一个进程。该进程会自动启动一个“主线程”，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。在此之前的所有程序都是单线程的。 线程生命周期线程是一个进程中的执行场景,一个进程可以启动多个线程 新建：采用 new 语句创建完成 就绪：执行 start 后 运行：占用 CPU 时间 阻塞：执行了 wait 语句、执行了 sleep 语句和等待某个对象锁，等待输入的场合 终止：退出 run()方法 多线程不是为了提高执行速度,而是提高应用程序的使用率. 线程和线程共享“堆内存和方法区内存”.栈内存是独立的,一个线程一个栈. 可以给现实世界中的人类一种错觉 : 感觉多线程在同时并发执行. 很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程 并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全:经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：void transferMoney(User from, User to, float amount){ to.setMoney(to.getBalance() + amount); from.setMoney(from.getBalance() - amount); } 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。 Java命令会启动Java虚拟机,启动JVM,等于启动了一个应用程序,表示启动了一个进程,该进程会自动启动一个”主线程”,然后主线程去调用某个类的main()方法,所以main()方法运行在主线程中. 线程的调度与控制 线程的调度模型分为: 分时调度模型和抢占式调度模型 Java使用抢占式调度模型 通常我们的计算机只有一个 CPU，CPU 在某一个时刻只能执行一条指令，线程只有得到 CPU时间片，也就是使用权，才可以执行指令。在单 CPU 的机器上线程不是并行运行的，只有在多个 CPU 上线程才可以并行运行。Java 虚拟机要负责线程的调度，取得 CPU 的使用权，目前有两种调度模型： 分时调度模型和抢占式调度模型，Java 使用抢占式调度模型。 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadTest1(); ThreadTest2(); ThreadTest3(); ThreadTest4(); ThreadTest5(); &#125; /** * 三个方法: 获取当前线程对象:Thread.currentThread(); 给线程起名: t1.setName("t1"); 获取线程的名字: t.getName(); */ private static void ThreadTest1() &#123; Thread t = Thread.currentThread();// t保存的内存地址指向的线程为"主线程" System.out.println(t.getId()); Thread t1 = new Thread(new Processor1()); // 给线程起名 t1.setName("t1"); t1.start(); Thread t2 = new Thread(new Processor1()); t2.setName("t2"); t2.start(); &#125; /** * 线程优先级高的获取的CPU时间片相对多一些 优先级: 1-10 最低: 1 最高: 10 默认: 5 */ private static void ThreadTest2() &#123; Thread t1 = new Processor2(); Thread t2 = new Processor2(); t1.setName("t1"); t2.setName("t2"); System.out.println(t1.getPriority()); System.out.println(t2.getPriority()); t1.setPriority(1); t2.setPriority(10); t1.start(); t2.start(); &#125; /** * 1.Thread.sleep(毫秒); 2.sleep方法是一个静态方法 3.该方法的作用: 阻塞当前线程,腾出CPU,让给其它线程 */ private static void ThreadTest3() &#123; Thread t = new Thread(new Processor3()); t.start(); for (int i = 0; i &lt; 11; i++) &#123; System.out.println(Thread.currentThread().getName() + "========&gt;" + i); try &#123; t.sleep(5000);// 等同于Thread.sleep(5000);阻塞的还是当前线程,和t线程无关. &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 某线程正在休眠,如何打断它的休眠 以下方式依靠的是异常处理机制 */ private static void ThreadTest4() &#123; try &#123; Thread t = new Thread(new Processor4()); t.start(); Thread.sleep(5000);// 睡5s t.interrupt();// 打断Thread的睡眠 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * 如何正确的更好的终止一个正在执行的线程 需求:线程启动5s之后终止. */ private static void ThreadTest5() &#123; Processor5 p = new Processor5(); Thread t = new Thread(p); t.start(); // 5s之后终止 try &#123; Thread.sleep(5000); p.isRun = false; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class Processor1 implements Runnable &#123; @Override public void run() &#123; Thread t = Thread.currentThread();// t保存的内存地址指向的线程为"t1线程对象" System.out.println(t.getName()); System.out.println(t.getId()); &#125;&#125;class Processor2 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; System.out.println(Thread.currentThread().getName() + "-----------&gt;" + i); &#125; &#125;&#125;class Processor3 implements Runnable &#123; /** * Thread中的run方法不能抛出异常,所以重写runn方法之后,在run方法的声明位置上不能使用throws 所以run方法中的异常只能try...catch... */ @Override public void run() &#123; for (int i = 0; i &lt; 11; i++) &#123; System.out.println(Thread.currentThread().getName() + "========&gt;" + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Processor4 implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000000000); System.out.println("能否执行这里"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 11; i++) &#123; System.out.println(Thread.currentThread().getName() + "========&gt;" + i); &#125; &#125;&#125;class Processor5 implements Runnable &#123; boolean isRun = true; @Override public void run() &#123; for (int i = 0; i &lt; 11; i++) &#123; if (isRun) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "========&gt;" + i); &#125; &#125; &#125;&#125; 线程优先级线程优先级主要分三种：MAX_PRIORITY(最高级); MIN_PRIORITY(最低级); NORM_PRIORITY(标准)默认 1234//设置线程的优先级，线程启动后不能再次设置优先级//必须在启动前设置优先级//设置最高优先级t1.setPriority(Thread.MAX_PRIORITY); sleep sleep 设置休眠的时间,单位毫秒，当一个线程遇到 sleep 的时候，就会睡眠，进入到阻塞状态,放弃 CPU，腾出 cpu 时间片，给其他线程用，所以在开发中通常我们会这样做，使其他的线程能够取得 CPU 时间片，当睡眠时间到达了，线程会进入可运行状态，得到 CPU 时间片继续执行，如果线程在睡眠状态被中断了，将会抛出 IterruptedException 123456789101112131415161718192021222324public class ThreadTest05 &#123; public static void main(String[] args) &#123; Runnable r1 = new Processor(); Thread t1 = new Thread(r1, "t1"); t1.start(); Thread t2 = new Thread(r1, "t2"); t2.start(); &#125; &#125; class Processor implements Runnable &#123; public void run() &#123; for (int i=0; i&lt;100; i++) &#123; System.out.println(Thread.currentThread().getName() + "," + i); if (i % 10 == 0) &#123; try &#123; //睡眠 100 毫秒，主要是放弃 CPU 的使用，将 CPU 时间片交给其他线程使用 Thread.sleep(100); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 停止一个线程 如果我们的线程正在睡眠，可以采用 interrupt 进行中断 通常定义一个标记，来判断标记的状态停止线程的执行 yield 它与 sleep()类似，只是不能由用户指定暂停多长时间，并且 yield()方法只能让同优先级的线程有执行的机会,采用 yieid 可以将 CPU 的使用权让给同一个优先级的线程 join 当前线程可以调用另一个线程的 join 方法，调用后当前线程会被阻塞不再执行，直到被调用的线程执行完毕，当前线程才会执行 synchronized 线程同步，指某一个时刻，指允许一个线程来访问共享资源，线程同步其实是对对象加锁，如果对象中的方法都是同步方法，那么某一时刻只能执行一个方法，采用线程同步解决以上的问题，我们只要保证线程一操作 s 时，线程 2 不允许操作即可，只有线程一使用完成 s 后，再让线程二来使用 s 变量 异步编程模型 : t1线程执行t1的,t2线程执行t2的,两个线程之间谁也不等谁 同步编程模型 : t1线程和t2线程执行,t2线程必须等t1线程执行结束之后,t2线程才能执行,这是同步编程模型 什么时候要用同步呢?为什么要引入线程同步呢? 为了数据的安全,尽管应用程序的使用率降低,但是为了保证数据是安全的,必须加入线程同步机制 线程同步机制使程序变成了(等同)单线程 2.什么条件下要使用线程同步? 第一: 必须是多线程环境 第二: 多线程环境共享同一个数据 第三: 共享的数据涉及到修改操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//synchronized 是对对象加锁//采用 synchronized 同步最好只同步有线程安全的代码//可以优先考虑使用 synchronized 同步块//因为同步的代码越多，执行的时间就会越长，其他线程等待的时间就会越长//影响效率public synchronized void run() &#123;//使用同步块synchronized (this) &#123; for (int i=0; i&lt;10; i++) &#123; s+=i; &#125;System.out.println(Thread.currentThread().getName() + ", s=" + s);s = 0;&#125;public class SynchronizedTest &#123; public static void main(String[] args) &#123; SynchronizeTest1(); &#125; private static void SynchronizeTest1() &#123; Account account=new Account("Actno-001",5000.0); Thread t1=new Thread(new Processor(account)); Thread t2=new Thread(new Processor(account)); t1.start(); t2.start(); &#125;&#125;/** * 取款线程 */class Processor implements Runnable&#123; Account act; Processor(Account act)&#123; this.act=act; &#125; @Override public void run() &#123; act.withdraw(1000.0); System.out.println("取款1000.0成功,余额: "+act.getBalance()); &#125;&#125;class Account &#123; private String actno; private double balance; public Account() &#123; super(); &#125; public Account(String actno, double balance) &#123; super(); this.actno = actno; this.balance = balance; &#125; public String getActno() &#123; return actno; &#125; public void setActno(String actno) &#123; this.actno = actno; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; /** * 对外提供一个取款的方法 对当前账户进行取款操作 */ public void withdraw(double money) &#123; //把需要同步的代码,放到同步语句块中. //遇到synchronized就找锁,找到就执行,找不到就等 /** * 原理: t1线程和t2线程 * t1线程执行到此处,遇到了synchronized关键字,就会去找this的对象锁, * 如果找到this对象锁,则进入同步语句块中执行程序,当同步语句块中的代码执行结束之后, * t1线程归还this的对象锁. * * 在t1线程执行同步语句块的过程中,如果t2线程也过来执行以下代码,也遇到synchronized关键字, * 所以也去找this对象锁,但是该对象锁被t1线程持有,只能在这等待this对象的归还. * * synchronized关键字添加到成员方法上,线程拿走的也是this的对象锁. * */ synchronized (this) &#123; double after = balance - money; try &#123; //延迟 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //更新 this.setBalance(after); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SynchronizedTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; MyClass mc1=new MyClass(); MyClass mc2=new MyClass(); Thread t1=new Thread(new Runnable1(mc1)); Thread t2=new Thread(new Runnable1(mc2)); t1.setName("t1"); t2.setName("t2"); t1.start(); //延迟,保证t1先执行 Thread.sleep(1000); t2.start(); &#125;&#125;class Runnable1 implements Runnable&#123; MyClass mc; Runnable1(MyClass mc)&#123; this.mc=mc; &#125; @Override public void run() &#123; if("t1".equals(Thread.currentThread().getName()))&#123; MyClass.m1();//因为是静态方法,用的还是类锁,和对象锁无关 &#125; if("t2".equals(Thread.currentThread().getName()))&#123; MyClass.m2(); &#125; &#125;&#125;class MyClass&#123; //synchronized添加到静态方法上,线程执行此方法的时候会找类锁,类锁只有一把 public synchronized static void m1()&#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("m1()............"); &#125; /** * m2()不会等m1结束,因为该方法没有被synchronized修饰 */// public static void m2()&#123;// System.out.println("m2()........");// &#125; /** * m2方法等m1结束之后才能执行,该方法有synchronized * 线程执行该方法需要"类锁",而类锁只有一个. */ public synchronized static void m2()&#123; System.out.println("m2()........"); &#125;&#125; 死锁12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DeadLock &#123; public static void main(String[] args) &#123; Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(new T1(o1, o2)); Thread t2 = new Thread(new T2(o1, o2)); t1.start(); t2.start(); &#125;&#125;class T1 implements Runnable &#123; Object o1; Object o2; T1(Object o1, Object o2) &#123; this.o1 = o1; this.o2 = o2; &#125; @Override public void run() &#123; synchronized (o1) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (o2) &#123; &#125; &#125; &#125;&#125;class T2 implements Runnable &#123; Object o1; Object o2; T2(Object o1, Object o2) &#123; this.o1 = o1; this.o2 = o2; &#125; @Override public void run() &#123; synchronized (o2) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (o1) &#123; &#125; &#125; &#125;&#125; 守护线程 从线程分类上可以分为：用户线程（以上讲的都是用户线程），另一个是守护线程。守护线程是这样的，所有的用户线程结束生命周期，守护线程才会结束生命周期，只要有一个用户线程存在，那么守护线程就不会结束，例如 java 中著名的垃圾回收器就是一个守护线程，只有应用程序中所有的线程结束，它才会结束。 其它所有的用户线程结束,则守护线程退出! 守护线程一般都是无限执行的. 12345678910111213141516171819202122232425262728293031public class DaemonThread &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Runnable2()); t1.setName("t1"); // 将t1这个用户线程修改成守护线程.在线程没有启动时可以修改以下参数 t1.setDaemon(true); t1.start(); // 主线程 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "-----&gt;" + i); Thread.sleep(1000); &#125; &#125;&#125;class Runnable2 implements Runnable &#123; @Override public void run() &#123; int i = 0; while (true) &#123; i++; System.out.println(Thread.currentThread().getName() + "--------&gt;" + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 设置为守护线程后，当主线程结束后，守护线程并没有把所有的数据输出完就结束了，也即是说守护线程是为用户线程服务的，当用户线程全部结束，守护线程会自动结束 Timer.schedule()123456789101112131415161718192021/** * 关于定时器的应用 作用: 每隔一段固定的时间执行一段代码 */public class TimerTest &#123; public static void main(String[] args) throws ParseException &#123; // 1.创建定时器 Timer t = new Timer(); // 2.指定定时任务 t.schedule(new LogTimerTask(), new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").parse("2017-06-29 14:24:00 000"), 10 * 1000); &#125;&#125;// 指定任务class LogTimerTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").format(new Date())); &#125;&#125;]]></content>
      <categories>
        <category>Java 多线程</category>
      </categories>
      <tags>
        <tag>Java 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合学习]]></title>
    <url>%2F2018%2F11%2F29%2FJava-%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Java集合学习笔记目录 集合类的由来 集合的特点 集合框架图 Collection的共性方法 迭代器的使用 有序重复同步问题 List 特有常见方法 list取出元素方法 ListIterator介绍 LinkedList ArrayList 哈希表确定元素是否相同 集合框架Collection练习 定义功能去除ArrayList中的重复元素 TreeSet中的比较 方法一 实现 Comparable 接口 方法二 构造一个比较器 Comparator TreeSet集合练习-字符串长度排序 Map&lt;K,V&gt;集合 Map&lt;K,V&gt; 遍历 集合类的由来对象封装特有数据，对象多了，需要存储，如果对象的个数不确定就用集合容器进行存储。 集合的特点用于存储对象的容器。集合的长度是可以改变的。集合中不可以存储基本数据类型值。 集合框架图 Collection的共性方法 迭代器的使用12345678910public static void main()&#123; //使用Collection 中的iterator()方法 Collection coll = new ArrayList(); //Iterator it = coll.iterator(); //while(it.hasNext()&#123;System.out.println(it.next());&#125;//it浪费内存，改成for for(Iterator it = coll.iterator(); it.hasNext(); )&#123; System.out.println(it.next()); &#125;&#125; 有序重复同步问题Collection: |--List: 存取有序 可重复 有索引 |--Vector: 可增长的对象数组 同步 效率低 增长100%空间浪费 查询增删都慢 |--ArrayList: 可增长的对象数组 不同步 效率高，替代了Vector。增长50%空间浪费 查询快 |--LinkedList: 内部是链表数据结构 不同步 增删快 |--set: 不可重复 不同步 set接口中的方法和Collection一致 |--HashSet 内部数据结构是哈希表 无序 不同步 |--LinkedHashSet 存取有序 |--TreeSet 有字典排序 Map&lt;K,V&gt; 无序 |--Hashtable：内部结构 哈希表 同步 不支持空键空值 |--Properties：用来存储键值对型的配置文件的信息。可以IO技术相结合。 |--HashMap：内部结构 哈希表 不同步 支持空键空值 |--LinkedHashMap 存取有序 |--TreeMap：内部结构二叉树 不同步 List特有常见方法 list取出元素方法 通过迭代器取出 使用get()123for(int x = 0; x &lt; list.size(); x++)&#123; System.out.println(list.get(x));&#125; ListIterator介绍ListIterator是Iterator的子接口，因为iterator接口中只有，hasNext() next() remove()三个方法，所以并不能完成在集合操作中，继续操作iterator，否则会出现ConcurrentModificationException异常。使用方法：1234567891011121314//可以实现在迭代中完成对元素的增删改查，只有list有这个ListIterator it = list.listIterator();//获取列表迭代器对象white(it.hasNext())&#123; Object obj = it.next(); if(obj.equals("abc2"))&#123; it.add("abc9"); //it.set("abc9"); &#125;&#125;System.out.println("list:" + list);/**************************结果：list：[abc1,abc2,abc9,abc3]**************************/ 附录ListIterator主要方法 LinkedList ArrayList引用类型的集合1234567891011121314ArrayList a1 = new ArrayList();a1.add(new Person("lisi1",21));a1.add(new Person("lisi2",22));Iterator it = a1.iterator();while(it.hasNext())&#123; Person p = (Person) it.next(); System.out.println(p.getName()+"--"+p.getAge());&#125;/************结果：lisi1--21lisi2--22*************/ 哈希表确定元素是否相同1.判断的是两个元素的哈希值是否相同。如果如果相同，再判断两个对象的内容是否相同。2.判断哈希值相同，其实就是对象的hashCode方法。判断内容用的是equals注意：如果哈希值不同，是不需要判断内容的。 集合框架Collection练习定义功能去除ArrayList中的重复元素123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; ArrayList a1 = new ArrayList(); a1.add("acb1"); a1.add("acb2"); a1.add("acb1"); System.out.println(a1); a1 = getSingleElement(a1); System.out.println(a1); &#125; private static ArrayList getSingleElement(ArrayList a1) &#123; //1.定义一个临时容器 ArrayList temp = new ArrayList(); //2.迭代a1集合 Iterator it = a1.iterator(); while (it.hasNext()) &#123; Object obj = it.next(); //3.判断被迭代到的元素是否在临时容器中 if (!temp.contains(obj)) &#123; temp.add(obj); &#125; &#125; return temp; &#125;/**********结果:[acb1, acb2, acb1][acb1, acb2]*********/ 注意： 对于ArrayList来说，去重复自定义对象时，自定义的对象需要和 equals 方法，因为 contains 方法依据的还是equals方法 TreeSet中的比较TreeSet判断元素唯一的方法就是根据返回值是否是0，是0，就是元素相同，不存。 方法一 实现 Comparable 接口此接口强行对实现它的每个类的对象进行整体排序。这种排序称为类的自然排序,类的compareTo方法称为他的自然比较法1234567891011Person implements Comparable&lt;Person&gt;&#123;... @Override public int compareTo(Person p)&#123; /*以Person对象的年龄从小到大的顺序排*/ /*年龄相同，以字典顺序比较姓名*/ int temp = this.age-p.age; return temp == 0 ? this.name.compareTo(p.name) : temp; &#125;&#125; 方法二 构造一个比较器 Comparator如果不要按照对象中具备的自然顺序进行排序。如果对象中不具备自然顺序。比较器 Comparator 强行对某个对象collection进行整体排序。方法：int compare(T o1,T o2)boolean equals(Object obj)1234567891011public class ComparatorByName implements Comparator&lt;Person&gt; &#123; @Override public int compare(Person p1, Person p2) &#123; int temp = p1.getName().compareTo(p2.getName()); return temp == 0 ? p1.getAge() - p2.getAge() : temp; &#125;&#125; 使用：1TreeSet ts = new TreeSet(new ComparatorByName()); TreeSet集合练习-字符串长度排序123456789101112131415public class ComparatorByLength implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; String s1 = (String) o1; String s2 = (String) o2; int temp = s1.length() - s2.length(); return temp == 0 ? s1.compareTo(s2) : temp; &#125;&#125; Map&lt;K,V&gt;集合Map与Collection区别？Map一次添加一对数据，Collection一次添加一个元素Map的Key不能重复，Value可以重复常见方法： Map&lt;K,V&gt; 遍历方法一：KeySet（） 将键作为对象存储在set中123456789101112131415161718192021222324252627public static void main(String[] args) &#123; HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); method(map); &#125; public static void method(Map&lt;Integer,String&gt; map) &#123; map.put(1, "abc1"); map.put(2, "abc2"); map.put(5, "abc5"); map.put(7, "abc7"); Set&lt;Integer&gt; keySet = map.keySet(); Iterator&lt;Integer&gt; it = keySet.iterator(); while (it.hasNext()) &#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+":::"+value); &#125;&#125;/***********1:::abc12:::abc25:::abc57:::abc7***********/ 方法二：entrySet() 该方法将键和值的映射关系作为对象，存储到了Set集合中，而这个映射关系类型就是Map.Entry类型12345678910111213141516171819202122232425262728 public static void main(String[] args) &#123; HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); method(map); &#125; public static void method(Map&lt;Integer,String&gt; map) &#123; map.put(1, "abc1"); map.put(2, "abc2"); map.put(5, "abc5"); map.put(7, "abc7"); Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; next = it.next(); Integer key = next.getKey(); String value = next.getValue(); System.out.println(key+":::"+value); &#125;&#125;/***********1:::abc12:::abc25:::abc57:::abc7***********/ *集合使用选择技巧 集合需要唯一吗？ 需要：Set 需要制定顺序吗？ 需要：TreeSet 不需要：HashSet 想要一个和存储一致顺序：LinkedHashSet 不需要：List 需要频繁增删吗？ 需要：LinkedList 不需要：ArrayList 如何记录每一个容器的结构和所属体系呢？ 看名字！ List |--ArrayList |--LinkedList Set |--HashSet |--TreeSet 看到array 就要想到数组，就要想到查询快，有角标。 看到link 就要想到链表，就要想到增删快，就要想到 add get remove first last的方法 看到hash 就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode方法和equals方法。 看到tree 就要想到二叉树，就要想到要排序，就要想到两个接口`Comparable` `Comparator` 而且通常这些常见的集合容器是不同步的。 **泛型1.jdk1.5后出现的安全机制。2.将运行时期的问题ClassCastException 转到了编译时期。3.避免了强制转换的麻烦。&lt;&gt;:什么时候用？当操作的引用数据类型不确定的时候，就用&lt;&gt;.4.泛型技术是给编译器使用的技术，用于编译时期，确保了类型的安全。运行时，会去泛型，生成的class文件中是不带泛型的，这个称为泛型的擦除。为什么擦除？为了兼容运行的类加载器。5.泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不必强制转换类型。]]></content>
      <categories>
        <category>Java 集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事物的传播行为]]></title>
    <url>%2F2018%2F11%2F29%2FSpring-%E4%BA%8B%E7%89%A9%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[什么是事物的传播行为？ 当事务方法被另一个事务方法调用时, 必须指定事务应该如何传播. 例如: 方法可能继续在现有事务中运行, 也可能开启一个新事务, 并在自己的事务中运行 事务的传播行为可以由传播属性指定. Spring 定义了 7 种类传播行为： 这里比较重要的是前两个 REQUIRED 传播行为 当 bookService 的 purchase() 方法被另一个事务方法 checkout() 调用时, 它默认会在现有的事务内运行. 这个默认的传播行为就是REQUIRED. 因此在 checkout() 方法的开始和终止边界内只有一个事务. 这个事务只在 checkout() 方法结束的时候被提交, 结果用户一本书都买不了 事务传播属性可以在 @Transactional 注解的 propagation 属性中定义 REQUIRES_NEW 传播行为 另一种常见的传播行为是 REQUIRES_NEW. 它表示该方法必须启动一个新事务, 并在自己的事务内运行. 如果有事务在运行, 就应该先挂起它 注意：以上传播行为的类别是在@Transactional注解上配置propagation来完成的，如果没有配置默认情况是REQUIRED Spring中事务的定义：Propagation1.PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择 比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候， ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA 的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。 这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被 提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚 2.PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行 如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行 这就跟平常用的普通非事务的代码只有一点点区别了。不理这个，因为我也没有觉得有什么区别 3.PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常 必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常 4.PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起 这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW， 那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后， 他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在 两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚， 如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交 5.PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ， 那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务 6.PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常 不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ， 那么ServiceB.methodB就要抛出异常了 7.PROPAGATION_NESTED 理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立， 而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。 而Nested事务的好处是他有一个savepoint。 ServiceA { /** * 事务属性配置为 PROPAGATION_REQUIRED */ void methodA() { try { //savepoint ServiceB.methodB(); //PROPAGATION_NESTED 级别 } catch (SomeException) { // 执行其他业务, 如 ServiceC.methodC(); } } } 也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如 ServiceC.methodC，继续执行，来尝试完成自己的事务。但是这个事务并没有在EJB标准中定义]]></content>
      <categories>
        <category>Java 框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事物的隔离级别]]></title>
    <url>%2F2018%2F11%2F29%2FSpring-%E4%BA%8B%E7%89%A9%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Spring 事物隔离级别 @Transactional(isolation = Isolation.READ_UNCOMMITTED） 保证了读取过程中不会读取到非法数据 @Transactional(isolation = Isolation.READ_COMMITTED) 大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，该级别适用于大多数系统 @Transactional(isolation = Isolation.REPEATABLE_READ) 保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失 @Transactional(isolation = Isolation.SERIALIZABLE) 最严格的级别，事务串行执行，资源消耗最大 读取到非法数据的现象 Dirty reads — 读脏数据 也就是说，比如事务A的未提交（还依然缓存）的数据被事务B读走，如果事务A失败回滚，会导致事务B所读取的的数据是错误的 non-repeatable reads — 不可重复读 比如事务A中两处读取数据-total-的值。在第一读的时候，total是100，然后事务B就把total的数据改成200，事务A再读一次，结果就发现，total竟然就变成200了，造成事务A数据混乱 phantom reads — 幻象读数据 这个和non-repeatable reads相似，也是同一个事务中多次读不一致的问题。但是non-repeatable reads的不一致是因为他所要取的数据集被改变了（比如total的数据），但是phantom reads所要读的数据的不一致却不是他所要读的数据集改变，而是他的条件数据集改变。比如select account.id where account.name=’grace’,第一次读去了6个符合条件的id，第二次读取的时候，由于事务b把一个帐号的名字由”dd”改成”grace”，结果取出来了7个数据 不可重复读的重点是修改：同样的条件, 你读取过的数据, 再次读取出来发现值不一样了幻读的重点在于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样。 而事务的隔离级别会导致读取到非法数据的情况如下表示： 脏读 不可重复读 幻读 SERIALIZABLE 不会 不会 不会 REPEATABLE_READ 不会 不会 会 READ_COMMITTED 不会 会 会 READ_UNCOMMITTED 会 会 会 常用数据库默认事务隔离级别: MYSQL：默认为REPEATABLE_READ SQLSERVER：默认为READ_COMMITTED ORACLE：默认为READ_COMMITTED @Transactiona注解中常用参数说明 @Transactiona注解中常用参数说明 readOnly 该属性用于设置当前事务是否为只读事务，设置为true表示只读，false 则表示可读写，默认值为false。 例如：@Transactional(readOnly=true) rollbackFor 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。 例如： 指定单一异常类：@Transactional(rollbackFor=RuntimeException.class) 指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class}) rollbackForClassName 该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。 例如： 指定单一异常类名称：@Transactional(rollbackForClassName=”RuntimeException”) 指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”, “Exception”}) noRollbackFor 该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。类似上面的rollbackFor。 noRollbackForClassName 该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。类似上面的rollbackForClassName。 propagation 该属性用于设置事务的传播行为，具体取值可参考上文。 例如：@Transactional(propagation=Propagation.NOT_SUPPORTED, readOnly=true) isolation 该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置 timeout 该属性用于设置事务的超时秒数，默认值为 -1 表示永不超时 需要注意的几点: @Transactional 只能被应用到public方法上,对于其它非public的方法,如果标记了也不会报错,但方法没有事务功能 Spring 团队的建议是你在具体的类（或类的方法）上使用@Transactional注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用@Transactional注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装 使用 Spring 事务管理器,由它来负责数据库的打开、提交、回滚]]></content>
      <categories>
        <category>Java 框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
