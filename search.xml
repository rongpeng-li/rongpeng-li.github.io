<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Data Elasticsearch (二)]]></title>
    <url>%2F2018%2F12%2F10%2FSpring-Data-Elasticsearch-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录 spring-data-elasticsearch 是什么？ Spring Data Spring Data Elasticsearch spring-data-elasticsearch 快速入门 pom.xml 依赖 ElasticsearchRepository ElasticsearchTemplate 使用案例 spring-data-elasticsearch 和 elasticsearch 版本 小结 spring-data-elasticsearch 是什么？Spring Data要了解 spring-data-elasticsearch 是什么，首先了解什么是 Spring Data。Spring Data 基于 Spring 为数据访问提供一种相似且一致性的编程模型，并保存底层数据存储的。 Spring Data Elasticsearchspring-data-elasticsearch 是 Spring Data 的 Community modules 之一，是 Spring Data 对 Elasticsearch 引擎的实现。Elasticsearch 默认提供轻量级的 HTTP Restful 接口形式的访问。相对来说，使用 HTTP Client 调用也很简单。但 spring-data-elasticsearch 可以更快的支持构建在 Spring 应用上，比如在 application.properties 配置 ES 节点信息和 spring-boot-starter-data-elasticsearch 依赖，直接在 Spring Boot 应用上使用。 spring-data-elasticsearch 快速入门pom.xml 依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;x.y.z.RELEASE&lt;/version&gt;&lt;/dependency&gt; ElasticsearchRepositoryES 通用的存储接口的一种默认实现。Spring 根据接口定义的方法名，具体执行对应的数据存储实现。ElasticsearchRepository 继承 ElasticsearchCrudRepository ，ElasticsearchCrudRepository 继承 PagingAndSortingRepository。所以一般 CRUD 带分页已经支持。 ElasticsearchTemplateES 数据操作的中心支持类。和 JdbcTemplate 一样，几乎所有操作都可以使用 ElasticsearchTemplate 来完成。ElasticsearchTemplate 实现了 ElasticsearchOperations 和 ApplicationContextAware 接口。ElasticsearchOperations 接口提供了 ES 相关的操作，并将 ElasticsearchTemplate 加入到 Spring 上下文。 使用案例官方案例，详细介绍了 Book ES 对象的接口实现。可以看出，book 拥有 name 和 price 两个属性。下面支持 name 和 price 列表 ES 查询，分页查询，范围查询等。还有可以利用注解实现 DSL 操作。12345678910public interface BookRepository extends Repository&lt;Book, String&gt; &#123; List&lt;Book&gt; findByNameAndPrice(String name, Integer price); List&lt;Book&gt; findByNameOrPrice(String name, Integer price); Page&lt;Book&gt; findByName(String name,Pageable page); Page&lt;Book&gt; findByNameNot(String name,Pageable page); Page&lt;Book&gt; findByPriceBetween(int price,Pageable page); Page&lt;Book&gt; findByNameLike(String name,Pageable page); @Query("&#123;\"bool\" : &#123;\"must\" : &#123;\"term\" : &#123;\"message\" : \"?0\"&#125;&#125;&#125;&#125;") Page&lt;Book&gt; findByMessage(String message, Pageable pageable);&#125; spring-data-elasticsearch 和 elasticsearch 版本SpringBoot 1.5+ 目前仅支持 ElasticSearch 2.3.2，所以如果想要使用最新的 ES。可以通过默认的轻量级的 HTTP 去调用实现。其版本对应如下: spring data elasticsearch elasticsearch3.0.0.BUILD-SNAPSHOT 5.4.02.0.4.RELEASE 2.4.02.0.0.RELEASE 2.2.01.4.0.M1 1.7.31.3.0.RELEASE 1.5.21.2.0.RELEASE 1.4.41.1.0.RELEASE 1.3.21.0.0.RELEASE 1.1.1 小结官方文档http://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/]]></content>
      <categories>
        <category>Spring Data Elasticsearch</category>
      </categories>
      <tags>
        <tag>Spring Data Elasticsearch (二)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data Elasticsearch (一)]]></title>
    <url>%2F2018%2F12%2F10%2FSpring-Data-Elasticsearch-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录 Elasticsearch 基本术语 文档（Document）、索引（Index）、类型（Type）文档三要素 文档（Document） 索引（Index） 类型（Type） 集群（Cluster）、节点（Node）、分片（Shard）分布式三要素 集群（Cluster） 节点（Node） 分片（Shard） Elasticsearch 工作原理 文档存储的路由 如何健康检查 如何水平扩容 小结 Elasticsearch 基本术语文档（Document）、索引（Index）、类型（Type）文档三要素文档（Document）文档，在面向对象观念就是一个对象。在 ES 里面，是一个大 JSON 对象，是指定了唯一 ID 的最底层或者根对象。文档的位置由 _index、_type 和 _id 唯一标识。 索引（Index）索引，用于区分文档成组，即分到一组的文档集合。索引，用于存储文档和使文档可被搜索。比如项目存索引 project 里面，交易存索引 sales 等。 类型（Type）类型，用于区分索引中的文档，即在索引中对数据逻辑分区。比如索引 project 的项目数据，根据项目类型 ui 项目、插画项目等进行区分。 和关系型数据库 MySQL 做个类比：Document 类似于 RecordType 类似于 TableIndex 类似于 Database 集群（Cluster）、节点（Node）、分片（Shard）分布式三要素集群（Cluster）服务器集群大家都知道，这里 ES 也是类似的。多个 ElasticSearch 运行实例（节点）组合的组合体是 ElasticSearch 集群。ElasticSearch 是天然的分布式，通过水平扩容为集群添加更多节点。集群是去中心化的，有一个主节点（Master）。主节点是动态选举，因此不会出现单点故障。 节点（Node）一个 ElasticSearch 运行实例就是节点。顺着集群来，任何节点都可以被选举成为主节点。主节点负责集群内所以变更，比如索引的增加、删除等。所以集群不会因为主节点流量的增大成为瓶颈。因为任何节点都会成为主节点。 分片（Shard）分片，是 ES 节点中最小的工作单元。分片仅仅保存全部数据的一部分，分片的集合是 ES 的索引。分片包括主分片和副分片，主分片是副分片的拷贝。主分片和副分片地工作基本没有大的区别。在索引中全文搜索，然后会查询到每个分片，将每个分配的结果进行全局地收集处理，并返回。 Elasticsearch 工作原理文档存储的路由当索引到一个文档（如：报价系统），具体的文档数据（如：报价数据）会存储到一个分片。具体文档数据会被切分，并分别存储在分片 1 或者 分片 2 … 那么如何确定存在哪个分片呢? 存储路由过程由下面地公式决定：1shard = hash(routing) % number_of_primary_shards routing 是可变值，支持自定义，默认文档 _id。hash 函数生成数字，经过取余算法得到余数，那么这个余数就是分片的位置。这是不是有点负载均衡的类似。 如何健康检查集群名，集群的健康状态12345678910111213GET http://127.0.0.1:9200/_cluster/stats&#123;&quot;cluster_name&quot;: &quot;elasticsearch&quot;,&quot;status&quot;: &quot;green&quot;,&quot;timed_out&quot;: false,&quot;number_of_nodes&quot;: 1,&quot;number_of_data_nodes&quot;: 1,&quot;active_primary_shards&quot;: 0,&quot;active_shards&quot;: 0,&quot;relocating_shards&quot;: 0,&quot;initializing_shards&quot;: 0,&quot;unassigned_shards&quot;: 0&#125; status 字段是需要我们关心的。状态可能是下列三个值之一： green所有的主分片和副本分片都已分配。你的集群是 100% 可用的。 yellow所有的主分片已经分片了，但至少还有一个副本是缺失的。不会有数据丢失，所以搜索结果依然是完整的。高可用会弱化把 yellow 想象成一个需要及时调查的警告。 red至少一个主分片（以及它的全部副本）都在缺失中。这意味着你在缺少数据：搜索只能返回部分数据，而分配到这个分片上的写入请求会返回一个异常。 active_primary_shards 集群中的主分片数量active_shards 所有分片的汇总值relocating_shards 显示当前正在从一个节点迁往其他节点的分片的数量。通常来说应该是 0，不过在 Elasticsearch 发现集群不太均衡时，该值会上涨。比如说：添加了一个新节点，或者下线了一个节点。initializing_shards 刚刚创建的分片的个数。unassigned_shards 已经在集群状态中存在的分片。 如何水平扩容主分片在索引创建已经确定。读操作可以同时被主分片和副分片处理。因此，更多的分片，会拥有更高的吞吐量。自然，需要增加更多的硬件资源支持吞吐量。说明，这里无法提高性能，因为每个分片获得的资源会变少。动态调整副本分片数，按需伸缩集群，比如把副本数默认值为 1 增加到 2：1234PUT /blogs/_settings&#123;&quot;number_of_replicas&quot; : 2&#125; 小结官方《Elasticsearch: 权威指南》https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html]]></content>
      <categories>
        <category>Spring Data Elasticsearch</category>
      </categories>
      <tags>
        <tag>Spring Data Elasticsearch (一)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql 双机异地热备]]></title>
    <url>%2F2018%2F12%2F07%2FMySql-%E5%8F%8C%E6%9C%BA%E5%BC%82%E5%9C%B0%E7%83%AD%E5%A4%87%2F</url>
    <content type="text"><![CDATA[目录 mysql 备份工作原理 mysql 主从 mysql 主主互备 双机热备的概念简单说一下，就是要保持两个数据库的状态自动同步。对任何一个数据库的操作都自动应用到另外一个数据库，始终保持两个数据库数据一致。 这样做的好处多。 可以做灾备，其中一个坏了可以切换到另一个。 可以做负载均衡，可以将请求分摊到其中任何一台上，提高网站吞吐量。 对于异地热备，尤其适合灾备。 mysql 备份工作原理简单的说就是把 一个服务器上执行过的sql语句在别的服务器上也重复执行一遍， 这样只要两个数据库的初态是一样的，那么它们就能一直同步。当然这种复制和重复都是mysql自动实现的，我们只需要配置即可。 上图中有两个服务器， 演示了从一个主服务器（master） 把数据同步到从服务器（slave）的过程。 这是一个主-从复制的例子。 主-主互相复制只是把上面的例子反过来再做一遍。 对于一个mysql服务器， 一般有两个线程来负责复制和被复制。当开启复制之后。 作为主服务器Master， 会把自己的每一次改动都记录到 二进制日志 Binarylog 中。 （从服务器会负责来读取这个log， 然后在自己那里再执行一遍。） 作为从服务器Slave， 会用master上的账号登陆到 master上， 读取master的Binarylog, 写入到自己的中继日志 Relaylog， 然后自己的sql线程会负责读取这个中继日志，并执行一遍。 到这里主服务器上的更改就同步到从服务器上了。 在mysql上可以查看当前服务器的主，从状态。 其实就是当前服务器的 Binary（作为主服务器角色）状态和位置。 以及其RelayLog（作为从服务器）的复制进度。 在主服务器上查看主状态： 1234567mysql&gt; show master status\G*************************** 1. row *************************** File: mysql-bin.000014 Position: 107 Binlog_Do_DB: Binlog_Ignore_DB: mysql,information_schema,performance_schema,amh1 row in set (0.00 sec) 第一行表明 当前正在记录的 binarylog文件名是： mysql-bin.000014. 我们可以在mysql数据目录下，找到这个文件： 第二行， 107. 表示当前的文件偏移量， 就是写入在mysql-bin.000014 文件的记录位置。 这两点就构成了 主服务器的状态。 配置从服务器的时候，需要用到这两个值。 告诉从服务器从哪读取主服务器的数据。 （从服务器会登录之后，找到这个日志文件，并从这个偏移量之后开始复制。） 第三行，和第四行，表示需要记录的数据库和需要忽略的数据库。 只有需要记录的数据库，其变化才会被写入到mysql-bin.000014日志文件中。 在从服务器上，查看从服务器的复制状态。 1234567891011121314151617181920212223242526272829mysql&gt; show slave status\G*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 198.**.***.*** Master_User: r******* Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000014 Read_Master_Log_Pos: 107 Relay_Log_File: mysqld-relay-bin.000013 Relay_Log_Pos: 253 Relay_Master_Log_File: mysql-bin.000014 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: mysql,information_schema,amh,performance_schema Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 107 Relay_Log_Space: 556 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_host 指的是 主服务器的地址。 Master_user 指的是主服务器上用来复制的用户。 从服务器会用此账号来登录主服务。进行复制。 Master_log_file 就是前面提到的， 主服务器上的日志文件名. Read_Master_log_pos 就是前面提到的主服务器的日志记录位置， 从服务器根据这两个条件来选择复制的文件和位置。 Slave_IO_Running: 指的就是从服务器上负责读取主服务器的线程工作状态。 从服务器用这个专门的线程链接到主服务器上，并把日志拷贝回来。 Slave_SQL_Running: 指的就是专门执行sql的线程。 它负责把复制回来的Relaylog执行到自己的数据库中。 这两个参数必须都为Yes 才表明复制在正常工作。 mysql 主从这里有两个重点， 要想同步数据库状态， 需要相同的初态，然后配置同步才有意义。 先以A服务器为起点， 配置它的数据库同步到B。 这就是主-从复制了。 之后再反过来做一次，就可以互相备份了。 1， 第一步， 在A上面创建专门用于备份的 用户： 1grant replication slave on *.* to &apos;repl_user&apos;@&apos;192.***.***.***&apos; identified by &apos;hj34$%&amp;mnkb&apos;; 上面把ip地址换成B机器的ip地址。 只允许B登录。安全。 用户名为： repl_user 密码为： hj34$**nkb 这个等会在B上面要用。 开启主服务器的 binarylog。 很多服务器是默认开启的，我们这里检查一下： 打开 /etc/my.cnf binlog-do-db 用来表示，只把哪些数据库的改动记录到binary日志中。 binlog-ignore-db 表示，需要忽略哪些数据库。 后面两个用于在 双主（多主循环）互相备份。 因为每台数据库服务器都可能在同一个表中插入数据，如果表有一个自动增长的主键，那么就会在多服务器上出现主键冲突。 解决这个问题的办法就是让每个数据库的自增主键不连续。 上图说是， 我假设需要将来可能需要10台服务器做备份， 所以auto-increment-increment 设为10. 而 auto-increment-offset=1 表示这台服务器的序号。 从1开始， 不超过auto-increment-increment。 这样做之后， 我在这台服务器上插入的第一个id就是 1， 第二行的id就是 11了， 而不是2. （同理，在第二台服务器上插入的第一个id就是2， 第二行就是12， 这个后面再介绍） 这样就不会出现主键冲突了。 后面我们会演示这个id的效果。 获取主服务器状态， 和同步初态。 假设我现在有这些数据库在A上面。 如果你是全新安装的， 那么不需要同步初态，直接跳过这一步，到后面直接查看主服务器状态。 这里我们假设有一个 hello 数据库作为初态。 先锁定 hello数据库：1FLUSH TABLES WITH READ LOCK; 然后导出数据： 只需要导出hello数据库， 如果你有多个数据库作为初态的话， 需要导出所有这些数据库： 然后查看A服务器的binary日志位置： 记住这个文件名和 位置， 等会在从服务器上会用到。 主服务器已经做完了， 可以解除锁定了： 设置从服务器 B 需要复制的数据库 打开从服务器 B 的 /etc/my.cnf 文件： server-id 必须保证每个服务器不一样。 这可能和循环同步有关。 防止进入死循环。 replicate-do-db 可以指定需要复制的数据库。 replicate-ignore-db 复制时需要排除的数据库, 除开系统的几个数据库之外，所有的数据库都复制。 relay_log 中继日志的名字。 前面说到了， 复制线程需要先把远程的变化拷贝到这个中继日志中， 在执行。 log-slave-updates 意思是，中继日志执行之后，这些变化是否需要计入自己的binarylog。 当你的B服务器需要作为另外一个服务器的主服务器的时候需要打开。 就是双主互相备份，或者多主循环备份。 保存， 重启mysql。 导入初态， 开始同步。 把刚才从A服务器上导出的 hello.sql 导入到 B的hello数据库中， 如果B现在没有hello数据库，请先创建一个， 然后再导入： 创建数据库：1mysql&gt; create database hello default charset utf8; 把hello.sql 上传到B上， 然后导入： 如果刚才导出了多个数据库， 需要把他们都一一上传导入。 开启同步, 在B服务器上执行：123456CHANGE MASTER TO MASTER_HOST=&apos;192.***.***.***&apos;, MASTER_USER=&apos;repl_user&apos;, MASTER_PASSWORD=&apos;hj3****&apos;, MASTER_LOG_FILE=&apos;mysql-bin.000004&apos;, MASTER_LOG_POS=7145; 重启mysql， 然后查看slave线程开启了没： 注意图中的红框， 两个都是Yes， 说明开启成功。 Slave_IO_Running: Yes Slave_SQL_Running: Yes 如果其中一个是No， 那就说明不成功。需要查看mysql的错误日志。 有时候密码填错了， 有时候防火墙的3306没有打开。ip地址不对，等等。 都会导致失败。 看错误日志: mysql的错误日志一般在： 到这里主-从复制已经打开了。 此时不要在B中修改数据。 我们接着配置从B到A的复制。 如果你只需要主从复制的话， 到这里就结束了。后面可以不看了。 所有A中的修改都能自动同步到B， 但是对B的修改却不能同步到A。 因为是单向的。 如果需要双向同步的话，需要再做一次从B到A的复制。 mysql 主主互备 在B中创建用户； 打开 /etc/my.cnf ， 开启B的binarylog： 注意红框中所新添加的部分。 我们不需要导出B的初态了，因为它刚刚才从A导过来。 直接记住它的master日志状态： 记住这两个数值，等会在A上面要用。 B服务器就设置完了 登录到A 服务器。 开启中继： 注意框中心添加的部分 启动同步： 上面的ip地址是B的ip地址， 因为A把B当做master了。 然后重启mysql服务。 然后查看，slave状态是否正常： 图中出现了两个No。 Slave_IO_Running: No Slave_SQL_Running: No 说明slave没有成功， 即，从B到A的同步没有成功。 我们去查看mysql错误日志 找到 机器名.err 文件，打开看看： 看图中的error信息。 说找不到中继日志文件。 这是因为我们在配置A的中继文件时改了中继文件名，但是mysql没有同步。解决办法很简单。 先停掉mysql服务。 找到这三个文件，把他们删掉。 一定要先停掉mysql服务。不然还是不成功。你需要重启一下机器了。 或者手动kill mysqld。 好了， 启动mysql之后。 我们在来检查一下slave状态： Slave_IO_Running: Yes Slave_SQL_Running: Yes 证明从B到A的复制也成功了。 至此， AB双主互相热备就介绍完了。]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql 双机异地热备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中抽象类和接口的区别]]></title>
    <url>%2F2018%2F12%2F05%2FJava%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[目录 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final (这里需要说一点,既然一个变量被final修饰了,那么这个变量就是一个常量!!!!!变量必须初始化成常量!!!!!)下面比较一下两者的语法区别： 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量!!!!!!!(注意重点在 普通 即 非静态 和 变量!!!!) 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 附录一个开发中接口的代码1234567891011121314151617public interface InterfaceTest &#123; // static 和 final 是针对接口中的成员变量来说的. // abstract是针对接口中的方法来说的. public static final String str = null; public String strr = null;// 接口中的变量默认是public static final类型的 public int i = 0;// 可以不显示的用static 和 final 来修饰这个变量.默认就是了!!! public abstract void fireContextsChangedEvent();// 方法默认是 public abstract类型的. public boolean checkValidParameterName(String oldParameterName, String newParameterName); public void saveToEmf(EList contextTypeList);&#125; 抽象类中可以包含静态方法(static)，接口中不能包含静态方法. 抽象类和接口中都可以包含静态成员变量(static)，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 一个类可以实现多个接口，但只能继承一个抽象类。 关于接口中定义的成员变量是常量的解释: 在interface里面的变量都是public static final 的。所以你可以这样写：public static final int i=10;或则int i=10；（可以省略掉一部分）注意在声明的时候要给变量赋予初值解释：首先你要弄清接口的含义.接口就是提供一种统一的’协议’,而接口中的属性也属于’协议’中的成员.它们是公共的,静态的,最终的常量.相当于全局常量.抽象类是不’完全’的类,相当于是接口和具体类的一个中间层.即满足接口的抽象,也满足具体的实现.如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口A中有一个public访问权限的静态变量a。按照java的语义，我们可以不通过实现接口的对象来访问变量a，通过A.a = xxx;就可以改变接口中的变量a的值了。正如抽象类中是可以这样做的，那么实现接口A的所有对象也都会自动拥有这一改变后的a的值了，也就是说一个地方改变了a，所有这些对象中a的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。 下面接着再说说两者在应用上的区别接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码(抽象出一个BaseServlet) 附上一个比较实用的BaseServlet.java123456789101112131415161718192021222324252627282930313233public class BaseServlet extends HttpServlet &#123; //BaseServlet虽然继承了HttpServlet但是不需要在web.xml中进行配置. /* * 它会根据请求中的m，来决定调用本类的哪个方法 */ protected void service(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=utf-8"); // 例如：http://localhost:8080/demo1/xxx?method=add String methodName = req.getParameter("method");//它是一个方法的名称 // 当没有指定要调用的方法时，那么默认请求的是execute()方法。 if(methodName==null || methodName.isEmpty())&#123; methodName = "execute"; &#125; Class c = this.getClass(); // 通过方法名称获取方法的反射对象 try &#123; Method m = c.getMethod(methodName,HttpServletRequest.class, HttpServletResponse.class); // 反射方法目标方法，也就是说，如果methodName为add，那么就调用add方法。 String result = (String) m.invoke(this, req,resp); // 通过返回值完成请求转发 if(result != null &amp;&amp; !result.isEmpty())&#123; req.getRequestDispatcher(result).forward(req, resp); &#125; &#125; catch (Exception e) &#123; throw new ServletException(e); &#125; &#125;&#125; 又比如比较典型的GenericServlet和其子类HttpServlet之间 GenericServlet.java123456789public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123; // abstract method abstract void service(ServletRequest req, ServletResponse res); void init() &#123; // Its implementation &#125; // other method related to Servlet&#125; 当HttpServlet类继承GenericServlet时，它提供了service方法的实现： HttpServlet.java123456789101112131415public class HttpServlet extends GenericServlet &#123; void service(ServletRequest req, ServletResponse res) &#123; // implementation &#125; protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; // Implementation &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123; // Implementation &#125; // some other methods related to HttpServlet&#125; 接口接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。以Externalizable接口为例： Externalizable.java123456public interface Externalizable extends Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 当你实现这个接口时，你就需要实现上面的两个方法：12345678910111213141516171819public class Employee implements Externalizable &#123; int employeeId; String employeeName; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; employeeId = in.readInt(); employeeName = (String) in.readObject(); &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeInt(employeeId); out.writeObject(employeeName); &#125;&#125; 抽象类和接口的对比 什么时候使用抽象类和接口 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。(如果有的方法不想让子类拥有设置flag) 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。Java8中的默认方法和静态方法Oracle已经开始尝试向接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。现在，我们可以为接口提供默认实现的方法了并且不用强制子类来实现它。]]></content>
      <categories>
        <category>Java 基本功</category>
      </categories>
      <tags>
        <tag>Java中抽象类和接口的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中final、finally、finalize的区别与用法]]></title>
    <url>%2F2018%2F12%2F05%2FJava%E4%B8%ADfinal%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录 简单区别 中等区别 详细区别 定义方法 定义类 finally语句 finalize方法 简单区别final 用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。finally 是异常处理语句结构的一部分，表示总是执行。finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。 中等区别虽然这个单词在Java中都存在，但是并没太多关联：final：java中的关键字，修饰符。 如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。 如果将变量或者方法声明为final，可以保证它们在使用中不被改变. 被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。 被声明final的方法只能使用，不能重载。 finally：java的一种异常处理机制。 finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。 finalize：Java中的一个方法名。 Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。 详细区别final、finally和finalize虽然长得像孪生兄弟一样，但是它们的含义和用法却是大相径庭。 final关键字我们首先来说说final。它可以用于以下四个地方: 定义变量，包括静态的和非静态的。 定义方法的参数。 定义方法。 定义类。 定义变量，包括静态的和非静态的。定义方法的参数 第一种情况 如果final修饰的是一个基本类型，就表示这个变量被赋予的值是不可变的，即它是个常量； 如果final修饰的是一个对象，就表示这个变量被赋予的引用是不可变的 这里需要提醒大家注意的是，不可改变的只是这个变量所保存的引用，并不是这个引用所指向的对象。 第二种情况：final的含义与第一种情况相同。实际上对于前两种情况，一种更贴切的表述final的含义的描述，那就是，如果一个变量或方法参数被final修饰，就表示它只能被赋值一次，但是JAVA虚拟机为变量设定的默认值不记作一次赋值。被final修饰的变量必须被初始化。初始化的方式以下几种： 在定义的时候初始化。 final变量可以在初始化块中初始化，不可以在静态初始化块中初始化。 静态final变量可以在定义时初始化，也可以在静态初始化块中初始化，不可以在初始化块中初始化。 final变量还可以在类的构造器中初始化，但是静态final变量不可以。 通过下面的代码可以验证以上的观点： 1234567891011121314151617181920212223242526272829303132333435363738public class FinalTest&#123; public final int A=10; //在定义时初始化 public final int B;&#123;B=20;&#125; //在初始化块中初始化 //非静态final变量不能在静态初始化块中初始化 //public final int C;static&#123;//C=30; &#125; //静态常量，在定义时初始化 public static final int STATIC_D=40; //静态常量，在静态初始化块中初始化 public static final int STATIC_E;static&#123;STATIC_E = 50;&#125; //静态变量不能在初始化块中初始化 //public static final int STATIC_F;&#123;STATIC_F=60;&#125; public final int G; //静态final变量不可以在构造器中初始化 //public static final int STATIC_H; //在构造器中初始化 public finalTest()&#123; G=70; //静态final变量不可以在构造器中初始化 //STATIC_H=80; //给final的变量第二次赋值时，编译会报错 //A=99; //STATIC_D=99; &#125; //final变量未被初始化，编译时就会报错 //public final int L; //静态final变量未被初始化，编译时就会报错 //public static final int STATIC_J;&#125; 我们运行上面的代码之后出了可以发现final变量（常量和静态final变量（静态常量被初始化时，编译会报错。用final修饰的变量（常量比非final的变量（普通变量拥更高的效率，因此我们在际编程中应该尽可能多的用常量来代替普通变量。 定义方法当final用来定义一个方法时，它表示这个方法不可以被子类重写，但是并不影响它被子类继承。我们写段代码来验证一下：123456789101112131415public class ParentClass&#123; public final void TestFinal()&#123; System.out.println("父类--这是一个final方法"); &#125;&#125;public class SubClass extends ParentClass&#123; //子类无法重写（override父类的final方法，否则编译时会报错 /* public void TestFinal()&#123; System.out.println("子类--重写final方法"); &#125; */ public static void main(String[]args)&#123; SubClass sc = new SubClass(); sc.TestFinal(); &#125;&#125; 这里需要特殊说明的是，具有private访问权限的方法也可以增加final修饰，但是由于子类无法继承private方法，因此也无法重写它。编译器在处理private方法时，是照final方来对待的，这样可以提高该方法被调用时的效率。不过子类仍然可以定义同父类中private方法具同样结构的方法，但是这并不会产生重写的效果，而且它们之间也不存在必然联系。 定义类最后我们再来回顾一下final用于类的情况。这个大家应该也很熟悉了，因为我们最常用的String类就是final的。由于final类不允许被继承，编译器在处理时把它的所方法都当作final的，因此final类比普通类拥更高的效率。而由关键字abstract定义的抽象类含必须由继承自它的子类重载实现的抽象方法，因此无法同时用final和abstract来修饰同一个类。同样的道理，final也不能用来修饰接口。 final的类的所方法都不能被重写，但这并不表示final的类的属性（变量值也是不可改变的，要想做到final类的属性值不可改变，必须给它增加final修饰，请看下面的例子：12345678910public final class FinalTest&#123; int i =20; final int j=50; public static void main(String[] args)&#123; FinalTest ft = new FinalTest(); ft.i = 99;/*final类FinalTest的属性值 i是可以改变的，因为属性值i前面没final修饰*/ //ft.j=49;//报错....因为j属性是final的不可以改变。 System.out.println(ft.i); &#125;&#125; 运行上面的代码试试看，结果是99，而不是初始化时的10。 finally语句finally只能用在try/catch语句中并且附带着一个语句块，表示这段语句最终总是被执行。请看下面的代码： 123456789101112public final class FinallyTest&#123; public static void main(String[] args)&#123; try&#123; throw new NullPointerException(); &#125;catch(NullPointerException e)&#123; System.out.println("程序抛出了异常"); &#125;finally&#123; //这里总会被执行，不受break,return影响另如数据库连接的close()一般写在这里，可以降低程序的出错几率 System.out.println("执行了finally语句块"); &#125; &#125;&#125; 运行结果说明了finally的作用： 程序抛出了异常 执行了finally语句块请大家注意，捕获程序抛出的异常之后，既不加处理，也不继续向上抛出异常，并不是良好的编程习惯，它掩盖了程序执行中发生的错误，这里只是方便演示，请不要学习。那么，没一种情况使finally语句块得不到执行呢？return、continue、break这个可以打乱代码顺序执行语句的规律。那我们就来试试看，这个语句是否能影响finally语句块的执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public final class FinallyTest &#123; //测试return语句 //结果显示：编译器在编译return new ReturnClass();时， //将它分成了两个步骤，new ReturnClass()和return，前一个创建对象的语句是在finally语句块之前被执行的， //而后一个return语句是在finally语句块之后执行的，也就是说finally语句块是在程序退出方法之前被执行的 public ReturnClass testReturn() &#123; try &#123; return new ReturnClass(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println("执行了finally语句"); &#125; return null; &#125; //测试continue语句 public void testContinue()&#123; for(int i=0; i&lt;3; i++)&#123; try &#123; System.out.println(i); if(i == 1)&#123; System.out.println("con"); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println("执行了finally语句"); &#125; &#125; &#125; //测试break语句 public void testBreak() &#123; for (int i=0; i&lt;3; i++) &#123; try &#123; System.out.println(i); if (i == 1) &#123; break; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println("执行了finally语句"); &#125; &#125; &#125; public static void main(String[] args) &#123; FinallyTest ft = new FinallyTest(); // 测试return语句 ft.testReturn(); System.out.println(); // 测试continue语句 ft.testContinue(); System.out.println(); // 测试break语句 ft.testBreak(); &#125;&#125;class ReturnClass &#123; public ReturnClass() &#123; System.out.println("执行了return语句"); &#125;&#125; 上面这段代码的运行结果如下：执行了return语句执行了finally语句执行了finally语句con执行了finally语句执行了finally语句执行了finally语句执行了finally语句 很明显，return、continue和break都没能阻止finally语句块的执行。从输出的结果来看，return语句似乎在finally语句块之前执行了，事实真的如此吗？我们来想想看，return语句的作用是什么呢？是退出当前的方法，并将值或对象返回。如果 finally语句块是在return语句之后执行的，那么return语句被执行后就已经退出当前方法了，finally语句块又如何能被执行呢？因此，正确的执行顺序应该是这样的：编译器在编译return new ReturnClass();时，将它分成了两个步骤，new ReturnClass()和return，前一个创建对象的语句是在finally语句块之前被执行的，而后一个return语句是在finally语句块之后执行的，也就是说finally语句块是在程序退出方法之前被执行的。同样，finally语句块是在循环被跳过（continue和中断（break之前被执行的 finalize方法finalize，它是一个方法，属于java.lang.Object类，它的定义如下：protected void finalize()throws Throwable{}众所周知，finalize()方法是GC（garbagecollector运行机制的一部分,在此我们只说说finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception，GC将终止对改对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。请看下面的示例：1234567891011public final class FinallyTest&#123; //重写finalize()方法 protected void finalize() throws Throwable&#123; System.out.println("执行了finalize()方法"); &#125; public static void main(String[] args)&#123; FinallyTest ft = new FinallyTest(); ft = null; System.gc(); &#125;&#125; 运行结果如下：• 执行了finalize()方法程序调用了java.lang.System类的gc()方法，引起GC的执行，GC在清理ft对象时调用了它的finalize()方法，因此才了上面的输出结果。调用System.gc()等同于调用下面这行代码：Runtime.getRuntime().gc();调用它们的作用只是建议垃圾收集器（GC启动，清理无用的对象释放内存空间，但是GC的启动并不是一定的，这由JAVA虚拟机来决定。直到 JAVA虚拟机停止运行，些对象的finalize()可能都没被运行过，那么怎样保证所对象的这个方法在JAVA虚拟机停止运行之前一定被调用呢？答案是我们可以调用System类的另一个方法：123public static void FunFinalizersOnExit(boolean value)&#123; //othercode&#125; 给这个方法传入true就可以保证对象的finalize()方法在JAVA虚拟机停止运行前一定被运行了，不过遗憾的是这个方法是不安全的，它会导致有用的对象finalize()被误调用，因此已不被赞成使用了。由于finalize()属于Object类，因此所类都这个方法，Object的任意子类都可以重写（override该方法，在其中释放系统资源或者做其它的清理工作，如关闭输入输出流。通过以上知识的回顾，我想大家对于final、finally、finalize的用法区别已经很清楚了。]]></content>
      <categories>
        <category>Java 基本功</category>
      </categories>
      <tags>
        <tag>Java中final、finally、finalize的区别与用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象的五大原则]]></title>
    <url>%2F2018%2F12%2F05%2FJava-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[目录 面向对象五大原则： 单一职责原则（Single-Resposibility Principle） 开放封闭原则（Open-Closed principle） 里氏替换原则（Liskov-Substituion Principle） 依赖倒置原则（Dependecy-Inversion Principle） ISP 接口隔离原则(Interface-Segregation Principle) 面向对象五大原则：单一职责原则（Single-Resposibility Principle）一个类应该仅有一个引起它变化的原因职员类例子： 比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要ifelse判断是哪种情况，从类结构上来说将会十分臃肿，并且上述三种的职员类型，不论哪一种发生需求变化，都会改变职员类！这个是大家所不愿意看到的！ 开放封闭原则（Open-Closed principle）对扩展是开放的，对更改是封闭的！变化来临时，如果不必改动软件实体裁的源代码，就能扩充它的行为，那么这个软件实体设计就是满足开放封闭原则的。如果说我们预测到某种变化，或者某种变化发生了，我们应当创建抽象类来隔离以后发生的同类变化。 里氏替换原则（Liskov-Substituion Principle）子类可以替换父类并且出现在父类能够出现的任何地方,贯彻GOF倡导的面向接口编程在这个原则中父类应尽可能使用接口或者抽象类来实现！子类通过实现了父类接口，能够替父类的使用地方！通过这个原则，我们客户端在使用父类接口的时候，通过子类实现！意思就是说我们依赖父类接口，在客户端声明一个父类接口，通过其子类来实现这个时候就要求子类必须能够替换父类所出现的任何地方，这样做的好处就是，在根据新要求扩展父类接口的新子类的时候而不影响当前客户端的使用！ 依赖倒置原则（Dependecy-Inversion Principle）传统的结构化编程中，最上层的模块通常都要依赖下面的子模块来实现，也称为高层依赖低层！所以DIP原则就是要逆转这种依赖关系，让高层模块不要依赖低层模块，所以称之为依赖倒置原则！ ISP 接口隔离原则(Interface-Segregation Principle)使用多个专门的接口比使用单个接口要好的多！这个我有体会，在我实际编程中，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！]]></content>
      <categories>
        <category>Java 基本功</category>
      </categories>
      <tags>
        <tag>Java 面向对象的五大原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象的特征]]></title>
    <url>%2F2018%2F12%2F05%2FJava-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[目录 封装 抽象 继承 多态 面向对象编程有三大特性：封装、继承、多态。 多态的实现 实现条件 实现形式 基于继承实现的多态 基于接口实现的多态 #面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。 封装封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。 抽象抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：1234class Person&#123; String name; int age; &#125;人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。## 继承在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 多态多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。例如，下面代码中的UserDao是一个接口，它定义引用变量userDao指向的实例对象由daofactory.getDao()在执行的时候返回，有时候指向的是UserJdbcDao这个实现，有时候指向的是UserHibernateDao这个实现，这样，不用修改源代码，就可以改变userDao指向的具体类实现，从而导致userDao.insertUser()方法调用的具体代码也随之改变，即有时候调用的是UserJdbcDao的insertUser方法，有时候调用的是UserHibernateDao的insertUser方法：12UserDao userDao = daofactory.getDao(); userDao.insertUser(user);# 面向对象编程有三大特性：封装、继承、多态。封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：酒 a = 剑南春酒 b = 五粮液酒 c = 酒鬼酒…这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：JNC a = new JNC();对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？Wine a = new JNC();在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了—1。123456789101112131415161718192021222324252627282930313233343536373839404142public class TestWine &#123; public static void main(String[] args) &#123; Wine a = new JNC(); a.fun1(); Wine b = new Wine(); b.fun1(); JNC c = new JNC(); c.fun1(); &#125; public static class Wine &#123; public void fun1()&#123; System.out.println("Wine 的Fun....."); fun2(); &#125; public void fun2()&#123; System.out.println("Wine 的Fun2..."); &#125; &#125; public static class JNC extends Wine&#123; /** * @desc 子类重载父类方法 * 父类中不存在该方法，向上转型后，父类是不能引用该方法的 * @param a * @return void */ public void fun1(String a)&#123; System.out.println("JNC 的 Fun1..."); fun2(); &#125; /** * 子类重写父类方法 * 指向子类的父类引用调用fun2时，必定是调用该方法 */ public void fun2()&#123; System.out.println("JNC 的Fun2..."); &#125; &#125;&#125;运行结果：Wine 的Fun…..JNC 的Fun2…Wine 的Fun…..Wine 的Fun2…Wine 的Fun…..JNC 的Fun2…从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。所以对于多态我们可以总结如下：指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。# 多态的实现## 实现条件继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。Java实现多态有三个必要条件：继承、重写、向上转型。1. 继承：在多态中必须存在有继承关系的子类和父类。2. 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。3. 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。## 实现形式在Java中有两种形式可以实现多态。继承和接口。#### 基于继承实现的多态基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class TestWine2 &#123; public static void main(String[] args) &#123; //定义父类数组 Wine[] wines = new Wine[2]; //定义两个子类 JNC jnc = new JNC(); JGJ jgj = new JGJ(); Wine wine=new Wine(); //父类引用子类对象 wines[0] = jnc; wines[1] = jgj; for(int i = 0 ; i &lt; 2 ; i++)&#123; System.out.println(wines[i].toString() + "--" + wines[i].drink()); &#125; System.out.println("-------------------------------"); System.out.println(jnc.toString() + "--" + jnc.drink()); System.out.println(jgj.toString() + "--" + jgj.drink()); &#125; public static class Wine &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Wine()&#123; &#125; public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return null; &#125; &#125; public static class JNC extends Wine&#123; public JNC()&#123; setName("JNC"); &#125; /** * 重写父类方法，实现多态 */ public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return "Wine : " + getName(); &#125; &#125; public static class JGJ extends Wine&#123; public JGJ()&#123; setName("JGJ"); &#125; /** * 重写父类方法，实现多态 */ public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return "Wine : " + getName(); &#125; &#125;&#125; 在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。 我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：123Object o = new JGJ();System.out.println(o.toString()); 输出的结果是Wine : JGJ。 Object、Wine、JGJ三者继承链关系是：JGJ—&gt;Wine—&gt;Object。所以我们可以这样说：当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用。但是注意如果这样写：123Object o = new Wine();System.out.println(o.toString()); 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。 所以基于继承实现的多态可以总结如下：对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。 如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。 基于接口实现的多态继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。 继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。]]></content>
      <categories>
        <category>Java 基本功</category>
      </categories>
      <tags>
        <tag>Java 面向对象的特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAop 理论]]></title>
    <url>%2F2018%2F12%2F04%2FSpringAop-%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[目录 什么是AOP AOP使用场景 AOP相关概念 Spring AOP组件 如何使用Spring AOP Spring AOP代理对象的生成 什么是AOPAOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。” 实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。 AOP使用场景AOP用来封装横切关注点，具体可以在下面的场景中使用: Authentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 AOP相关概念方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用spring的 Advisor或拦截器实现。 连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。 通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice 切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上 引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口 目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。 Spring AOP组件下面这种类图列出了Spring中主要的AOP组件 如何使用Spring AOP可以通过配置文件或者编程的方式来使用Spring AOP 配置可以通过xml文件来进行，大概有四种方式： 配置ProxyFactoryBean，显式地设置advisors, advice, target等 配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象 通过aop:config来配置 通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点 也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象 Spring AOP代理对象的生成Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关代码：123456789101112131415/** * &lt;ol&gt; * &lt;li&gt;获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false) * &lt;li&gt;检查上面得到的接口中有没有定义 equals或者hashcode的接口 * &lt;li&gt;调用Proxy.newProxyInstance创建代理对象 * &lt;/ol&gt; */public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Creating JDK dynamic proxy: target source is " +this.advised.getTargetSource()); &#125; Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(this.advised); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 下面的问题是，代理对象生成了，那切面是如何织入的？ 我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下Spring AOP是如何织入切面的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273publicObject invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; MethodInvocation invocation = null; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Class targetClass = null; Object target = null; try &#123; //eqauls()方法，具目标对象未实现此方法 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method))&#123; return (equals(args[0])? Boolean.TRUE : Boolean.FALSE); &#125; //hashCode()方法，具目标对象未实现此方法 if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method))&#123; return newInteger(hashCode()); &#125; //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知 if (!this.advised.opaque &amp;&amp;method.getDeclaringClass().isInterface() &amp;&amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123; // Service invocations onProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args); &#125; Object retVal = null; if (this.advised.exposeProxy) &#123; // Make invocation available ifnecessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; //获得目标对象的类 target = targetSource.getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; //获取可以应用到此方法上的Interceptor列表 List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass); //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args) if (chain.isEmpty()) &#123; retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args); &#125; else &#123; //创建MethodInvocation invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed(); &#125; // Massage return value if necessary. if (retVal != null &amp;&amp; retVal == target &amp;&amp;method.getReturnType().isInstance(proxy) &amp;&amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123; // Special case: it returned"this" and the return type of the method // is type-compatible. Notethat we can't help if the target sets // a reference to itself inanother returned object. retVal = proxy; &#125; return retVal; &#125; finally &#123; if (target != null &amp;&amp; !targetSource.isStatic()) &#123; // Must have come fromTargetSource. targetSource.releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 主流程可以简述为：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,则应用通知,并执行joinpoint; 如果没有,则直接反射执行joinpoint。而这里的关键是通知链是如何获取的以及它又是如何执行的，下面逐一分析下。12345678910public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123; MethodCacheKeycacheKey = new MethodCacheKey(method); List&lt;Object&gt;cached = this.methodCache.get(cacheKey); if(cached == null) &#123; cached= this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice( this,method, targetClass); this.methodCache.put(cacheKey,cached); &#125; returncached;&#125; 可以看到实际的获取工作其实是由AdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice()这个方法来完成的，获取到的结果会被缓存。 下面来分析下这个方法的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor, * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断 * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回. */publicList getInterceptorsAndDynamicInterceptionAdvice(Advised config, Methodmethod, Class targetClass) &#123; // This is somewhat tricky... we have to process introductions first, // but we need to preserve order in the ultimate list. List interceptorList = new ArrayList(config.getAdvisors().length); //查看是否包含IntroductionAdvisor boolean hasIntroductions = hasMatchingIntroductions(config,targetClass); //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); Advisor[] advisors = config.getAdvisors(); for (int i = 0; i &lt;advisors.length; i++) &#123; Advisor advisor = advisors[i]; if (advisor instanceof PointcutAdvisor) &#123; // Add it conditionally. PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor; if(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123; //TODO: 这个地方这两个方法的位置可以互换下 //将Advisor转化成Interceptor MethodInterceptor[]interceptors = registry.getInterceptors(advisor); //检查当前advisor的pointcut是否可以匹配当前方法 MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher(); if (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) &#123; if(mm.isRuntime()) &#123; // Creating a newobject instance in the getInterceptors() method // isn't a problemas we normally cache created chains. for (intj = 0; j &lt; interceptors.length; j++) &#123; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptors[j],mm)); &#125; &#125; else &#123; interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; &#125; &#125; else if (advisor instanceof IntroductionAdvisor)&#123; IntroductionAdvisor ia =(IntroductionAdvisor) advisor; if(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123; Interceptor[] interceptors= registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; else &#123; Interceptor[] interceptors =registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; return interceptorList;&#125; 这个方法执行完成后，Advised中配置能够应用到连接点或者目标类的Advisor全部被转化成了MethodInterceptor. 接下来我们再看下得到的拦截器链是怎么起作用的。1234567if (chain.isEmpty()) &#123; retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);&#125; else &#123; //创建MethodInvocation invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed();&#125; 从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建MethodInvocation，调用其proceed方法，触发拦截器链的执行，来看下具体代码123456789101112131415161718192021222324252627282930313233public Object proceed() throws Throwable &#123; // We start with an index of -1and increment early. if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()- 1) &#123; //如果Interceptor执行完了，则执行joinPoint return invokeJoinpoint(); &#125; Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); //如果要动态匹配joinPoint if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)&#123; // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice; //动态匹配：运行时参数是否满足匹配条件 if (dm.methodMatcher.matches(this.method, this.targetClass,this.arguments)) &#123; //执行当前Intercetpor returndm.interceptor.invoke(this); &#125; else &#123; //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor return proceed(); &#125; &#125; else &#123; // It's an interceptor, so we just invoke it: The pointcutwill have // been evaluated statically before this object was constructed. //执行当前Intercetpor return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125;]]></content>
      <categories>
        <category>Java 框架</category>
      </categories>
      <tags>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 工作原理]]></title>
    <url>%2F2018%2F12%2F04%2FSpringMVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[目录 SpringMVC的工作原理图： SpringMVC流程 组件说明 组件： SpringMVC的工作原理图： SpringMVC流程 用户发送请求至前端控制器DispatcherServlet。 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet调用HandlerAdapter处理器适配器。 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 Controller执行完成返回ModelAndView。 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ViewReslover解析后返回具体View。 DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应用户。 组件说明以下组件通常使用框架提供实现： DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。 ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。 组件：1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供作用：根据请求的url查找HandlerHandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 3、处理器适配器HandlerAdapter作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 4、处理器Handler(需要工程师开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行HandlerHandler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。 5、视图解析器View resolver(不需要工程师开发),由框架提供作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。 6、视图View(需要工程师开发jsp…)View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）]]></content>
      <categories>
        <category>Java 框架</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程]]></title>
    <url>%2F2018%2F12%2F04%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录 多线程的基本概念 什么是进程 多进程有什么作用？ 什么是线程 多线程有什么作用？ java 程序的运行原理？ 线程生命周期 线程的调度与控制 线程优先级 sleep 停止一个线程 yield join synchronized 死锁 守护线程 Timer.schedule() 多线程的基本概念线程指进程中的一个执行场景，也就是执行流程，那么进程和线程有什么区别呢？ 每个进程是一个应用程序，都有独立的内存空间 同一个进程中的线程共享其进程中的内存和资源（共享的内存是堆内存和方法区内存，栈内存不共享，每个线程有自己的。） 什么是进程一个进程对应一个应用程序。例如：在 windows 操作系统启动 Word 就表示启动了一个进程。在 java 的开发环境下启动 JVM，就表示启动了一个进程。现代的计算机都是支持多进程的，在同一个操作系统中，可以同时启动多个进程。 多进程有什么作用？单进程计算机只能做一件事情。玩电脑，一边玩游戏（游戏进程）一边听音乐（音乐进程）。对于单核计算机来讲，在同一个时间点上，游戏进程和音乐进程是同时在运行吗？不是。因为计算机的 CPU 只能在某个时间点上做一件事。由于计算机将在“游戏进程”和“音乐进程”之间频繁的切换执行，切换速度极高，人类感觉游戏和音乐在同时进行。多进程的作用不是提高执行速度，而是提高 CPU 的使用率。进程和进程之间的内存是独立的。 什么是线程线程是一个进程中的执行场景。一个进程可以启动多个线程。 多线程有什么作用？多线程不是为了提高执行速度，而是提高应用程序的使用率。线程和线程共享“堆内存和方法区内存”，栈内存是独立的，一个线程一个栈。可以给现实世界中的人类一种错觉：感觉多个线程在同时并发执行。 java 程序的运行原理？java 命令会启动 java 虚拟机，启动 JVM，等于启动了一个应用程序，表示启动了一个进程。该进程会自动启动一个“主线程”，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。在此之前的所有程序都是单线程的。 线程生命周期线程是一个进程中的执行场景,一个进程可以启动多个线程 新建：采用 new 语句创建完成 就绪：执行 start 后 运行：占用 CPU 时间 阻塞：执行了 wait 语句、执行了 sleep 语句和等待某个对象锁，等待输入的场合 终止：退出 run()方法 多线程不是为了提高执行速度,而是提高应用程序的使用率. 线程和线程共享“堆内存和方法区内存”.栈内存是独立的,一个线程一个栈. 可以给现实世界中的人类一种错觉 : 感觉多线程在同时并发执行. 很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程 并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全:经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：void transferMoney(User from, User to, float amount){ to.setMoney(to.getBalance() + amount); from.setMoney(from.getBalance() - amount); } 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。 Java命令会启动Java虚拟机,启动JVM,等于启动了一个应用程序,表示启动了一个进程,该进程会自动启动一个”主线程”,然后主线程去调用某个类的main()方法,所以main()方法运行在主线程中. 线程的调度与控制 线程的调度模型分为: 分时调度模型和抢占式调度模型 Java使用抢占式调度模型 通常我们的计算机只有一个 CPU，CPU 在某一个时刻只能执行一条指令，线程只有得到 CPU时间片，也就是使用权，才可以执行指令。在单 CPU 的机器上线程不是并行运行的，只有在多个 CPU 上线程才可以并行运行。Java 虚拟机要负责线程的调度，取得 CPU 的使用权，目前有两种调度模型： 分时调度模型和抢占式调度模型，Java 使用抢占式调度模型。 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadTest1(); ThreadTest2(); ThreadTest3(); ThreadTest4(); ThreadTest5(); &#125; /** * 三个方法: 获取当前线程对象:Thread.currentThread(); 给线程起名: t1.setName("t1"); 获取线程的名字: t.getName(); */ private static void ThreadTest1() &#123; Thread t = Thread.currentThread();// t保存的内存地址指向的线程为"主线程" System.out.println(t.getId()); Thread t1 = new Thread(new Processor1()); // 给线程起名 t1.setName("t1"); t1.start(); Thread t2 = new Thread(new Processor1()); t2.setName("t2"); t2.start(); &#125; /** * 线程优先级高的获取的CPU时间片相对多一些 优先级: 1-10 最低: 1 最高: 10 默认: 5 */ private static void ThreadTest2() &#123; Thread t1 = new Processor2(); Thread t2 = new Processor2(); t1.setName("t1"); t2.setName("t2"); System.out.println(t1.getPriority()); System.out.println(t2.getPriority()); t1.setPriority(1); t2.setPriority(10); t1.start(); t2.start(); &#125; /** * 1.Thread.sleep(毫秒); 2.sleep方法是一个静态方法 3.该方法的作用: 阻塞当前线程,腾出CPU,让给其它线程 */ private static void ThreadTest3() &#123; Thread t = new Thread(new Processor3()); t.start(); for (int i = 0; i &lt; 11; i++) &#123; System.out.println(Thread.currentThread().getName() + "========&gt;" + i); try &#123; t.sleep(5000);// 等同于Thread.sleep(5000);阻塞的还是当前线程,和t线程无关. &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 某线程正在休眠,如何打断它的休眠 以下方式依靠的是异常处理机制 */ private static void ThreadTest4() &#123; try &#123; Thread t = new Thread(new Processor4()); t.start(); Thread.sleep(5000);// 睡5s t.interrupt();// 打断Thread的睡眠 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * 如何正确的更好的终止一个正在执行的线程 需求:线程启动5s之后终止. */ private static void ThreadTest5() &#123; Processor5 p = new Processor5(); Thread t = new Thread(p); t.start(); // 5s之后终止 try &#123; Thread.sleep(5000); p.isRun = false; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class Processor1 implements Runnable &#123; @Override public void run() &#123; Thread t = Thread.currentThread();// t保存的内存地址指向的线程为"t1线程对象" System.out.println(t.getName()); System.out.println(t.getId()); &#125;&#125;class Processor2 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; System.out.println(Thread.currentThread().getName() + "-----------&gt;" + i); &#125; &#125;&#125;class Processor3 implements Runnable &#123; /** * Thread中的run方法不能抛出异常,所以重写runn方法之后,在run方法的声明位置上不能使用throws 所以run方法中的异常只能try...catch... */ @Override public void run() &#123; for (int i = 0; i &lt; 11; i++) &#123; System.out.println(Thread.currentThread().getName() + "========&gt;" + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Processor4 implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000000000); System.out.println("能否执行这里"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 11; i++) &#123; System.out.println(Thread.currentThread().getName() + "========&gt;" + i); &#125; &#125;&#125;class Processor5 implements Runnable &#123; boolean isRun = true; @Override public void run() &#123; for (int i = 0; i &lt; 11; i++) &#123; if (isRun) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "========&gt;" + i); &#125; &#125; &#125;&#125; 线程优先级线程优先级主要分三种：MAX_PRIORITY(最高级); MIN_PRIORITY(最低级); NORM_PRIORITY(标准)默认 1234//设置线程的优先级，线程启动后不能再次设置优先级//必须在启动前设置优先级//设置最高优先级t1.setPriority(Thread.MAX_PRIORITY); sleep sleep 设置休眠的时间,单位毫秒，当一个线程遇到 sleep 的时候，就会睡眠，进入到阻塞状态,放弃 CPU，腾出 cpu 时间片，给其他线程用，所以在开发中通常我们会这样做，使其他的线程能够取得 CPU 时间片，当睡眠时间到达了，线程会进入可运行状态，得到 CPU 时间片继续执行，如果线程在睡眠状态被中断了，将会抛出 IterruptedException 123456789101112131415161718192021222324public class ThreadTest05 &#123; public static void main(String[] args) &#123; Runnable r1 = new Processor(); Thread t1 = new Thread(r1, "t1"); t1.start(); Thread t2 = new Thread(r1, "t2"); t2.start(); &#125; &#125; class Processor implements Runnable &#123; public void run() &#123; for (int i=0; i&lt;100; i++) &#123; System.out.println(Thread.currentThread().getName() + "," + i); if (i % 10 == 0) &#123; try &#123; //睡眠 100 毫秒，主要是放弃 CPU 的使用，将 CPU 时间片交给其他线程使用 Thread.sleep(100); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 停止一个线程 如果我们的线程正在睡眠，可以采用 interrupt 进行中断 通常定义一个标记，来判断标记的状态停止线程的执行 yield 它与 sleep()类似，只是不能由用户指定暂停多长时间，并且 yield()方法只能让同优先级的线程有执行的机会,采用 yieid 可以将 CPU 的使用权让给同一个优先级的线程 join 当前线程可以调用另一个线程的 join 方法，调用后当前线程会被阻塞不再执行，直到被调用的线程执行完毕，当前线程才会执行 synchronized 线程同步，指某一个时刻，指允许一个线程来访问共享资源，线程同步其实是对对象加锁，如果对象中的方法都是同步方法，那么某一时刻只能执行一个方法，采用线程同步解决以上的问题，我们只要保证线程一操作 s 时，线程 2 不允许操作即可，只有线程一使用完成 s 后，再让线程二来使用 s 变量 异步编程模型 : t1线程执行t1的,t2线程执行t2的,两个线程之间谁也不等谁 同步编程模型 : t1线程和t2线程执行,t2线程必须等t1线程执行结束之后,t2线程才能执行,这是同步编程模型 什么时候要用同步呢?为什么要引入线程同步呢? 为了数据的安全,尽管应用程序的使用率降低,但是为了保证数据是安全的,必须加入线程同步机制 线程同步机制使程序变成了(等同)单线程 2.什么条件下要使用线程同步? 第一: 必须是多线程环境 第二: 多线程环境共享同一个数据 第三: 共享的数据涉及到修改操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//synchronized 是对对象加锁//采用 synchronized 同步最好只同步有线程安全的代码//可以优先考虑使用 synchronized 同步块//因为同步的代码越多，执行的时间就会越长，其他线程等待的时间就会越长//影响效率public synchronized void run() &#123;//使用同步块synchronized (this) &#123; for (int i=0; i&lt;10; i++) &#123; s+=i; &#125;System.out.println(Thread.currentThread().getName() + ", s=" + s);s = 0;&#125;public class SynchronizedTest &#123; public static void main(String[] args) &#123; SynchronizeTest1(); &#125; private static void SynchronizeTest1() &#123; Account account=new Account("Actno-001",5000.0); Thread t1=new Thread(new Processor(account)); Thread t2=new Thread(new Processor(account)); t1.start(); t2.start(); &#125;&#125;/** * 取款线程 */class Processor implements Runnable&#123; Account act; Processor(Account act)&#123; this.act=act; &#125; @Override public void run() &#123; act.withdraw(1000.0); System.out.println("取款1000.0成功,余额: "+act.getBalance()); &#125;&#125;class Account &#123; private String actno; private double balance; public Account() &#123; super(); &#125; public Account(String actno, double balance) &#123; super(); this.actno = actno; this.balance = balance; &#125; public String getActno() &#123; return actno; &#125; public void setActno(String actno) &#123; this.actno = actno; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; /** * 对外提供一个取款的方法 对当前账户进行取款操作 */ public void withdraw(double money) &#123; //把需要同步的代码,放到同步语句块中. //遇到synchronized就找锁,找到就执行,找不到就等 /** * 原理: t1线程和t2线程 * t1线程执行到此处,遇到了synchronized关键字,就会去找this的对象锁, * 如果找到this对象锁,则进入同步语句块中执行程序,当同步语句块中的代码执行结束之后, * t1线程归还this的对象锁. * * 在t1线程执行同步语句块的过程中,如果t2线程也过来执行以下代码,也遇到synchronized关键字, * 所以也去找this对象锁,但是该对象锁被t1线程持有,只能在这等待this对象的归还. * * synchronized关键字添加到成员方法上,线程拿走的也是this的对象锁. * */ synchronized (this) &#123; double after = balance - money; try &#123; //延迟 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //更新 this.setBalance(after); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SynchronizedTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; MyClass mc1=new MyClass(); MyClass mc2=new MyClass(); Thread t1=new Thread(new Runnable1(mc1)); Thread t2=new Thread(new Runnable1(mc2)); t1.setName("t1"); t2.setName("t2"); t1.start(); //延迟,保证t1先执行 Thread.sleep(1000); t2.start(); &#125;&#125;class Runnable1 implements Runnable&#123; MyClass mc; Runnable1(MyClass mc)&#123; this.mc=mc; &#125; @Override public void run() &#123; if("t1".equals(Thread.currentThread().getName()))&#123; MyClass.m1();//因为是静态方法,用的还是类锁,和对象锁无关 &#125; if("t2".equals(Thread.currentThread().getName()))&#123; MyClass.m2(); &#125; &#125;&#125;class MyClass&#123; //synchronized添加到静态方法上,线程执行此方法的时候会找类锁,类锁只有一把 public synchronized static void m1()&#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("m1()............"); &#125; /** * m2()不会等m1结束,因为该方法没有被synchronized修饰 */// public static void m2()&#123;// System.out.println("m2()........");// &#125; /** * m2方法等m1结束之后才能执行,该方法有synchronized * 线程执行该方法需要"类锁",而类锁只有一个. */ public synchronized static void m2()&#123; System.out.println("m2()........"); &#125;&#125; 死锁12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DeadLock &#123; public static void main(String[] args) &#123; Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(new T1(o1, o2)); Thread t2 = new Thread(new T2(o1, o2)); t1.start(); t2.start(); &#125;&#125;class T1 implements Runnable &#123; Object o1; Object o2; T1(Object o1, Object o2) &#123; this.o1 = o1; this.o2 = o2; &#125; @Override public void run() &#123; synchronized (o1) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (o2) &#123; &#125; &#125; &#125;&#125;class T2 implements Runnable &#123; Object o1; Object o2; T2(Object o1, Object o2) &#123; this.o1 = o1; this.o2 = o2; &#125; @Override public void run() &#123; synchronized (o2) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (o1) &#123; &#125; &#125; &#125;&#125; 守护线程 从线程分类上可以分为：用户线程（以上讲的都是用户线程），另一个是守护线程。守护线程是这样的，所有的用户线程结束生命周期，守护线程才会结束生命周期，只要有一个用户线程存在，那么守护线程就不会结束，例如 java 中著名的垃圾回收器就是一个守护线程，只有应用程序中所有的线程结束，它才会结束。 其它所有的用户线程结束,则守护线程退出! 守护线程一般都是无限执行的. 12345678910111213141516171819202122232425262728293031public class DaemonThread &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Runnable2()); t1.setName("t1"); // 将t1这个用户线程修改成守护线程.在线程没有启动时可以修改以下参数 t1.setDaemon(true); t1.start(); // 主线程 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "-----&gt;" + i); Thread.sleep(1000); &#125; &#125;&#125;class Runnable2 implements Runnable &#123; @Override public void run() &#123; int i = 0; while (true) &#123; i++; System.out.println(Thread.currentThread().getName() + "--------&gt;" + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 设置为守护线程后，当主线程结束后，守护线程并没有把所有的数据输出完就结束了，也即是说守护线程是为用户线程服务的，当用户线程全部结束，守护线程会自动结束 Timer.schedule()123456789101112131415161718192021/** * 关于定时器的应用 作用: 每隔一段固定的时间执行一段代码 */public class TimerTest &#123; public static void main(String[] args) throws ParseException &#123; // 1.创建定时器 Timer t = new Timer(); // 2.指定定时任务 t.schedule(new LogTimerTask(), new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").parse("2017-06-29 14:24:00 000"), 10 * 1000); &#125;&#125;// 指定任务class LogTimerTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").format(new Date())); &#125;&#125;]]></content>
      <categories>
        <category>Java 多线程</category>
      </categories>
      <tags>
        <tag>Java 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合学习]]></title>
    <url>%2F2018%2F11%2F29%2FJava-%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Java集合学习笔记目录 集合类的由来 集合的特点 集合框架图 Collection的共性方法 迭代器的使用 有序重复同步问题 List 特有常见方法 list取出元素方法 ListIterator介绍 LinkedList ArrayList 哈希表确定元素是否相同 集合框架Collection练习 定义功能去除ArrayList中的重复元素 TreeSet中的比较 方法一 实现 Comparable 接口 方法二 构造一个比较器 Comparator TreeSet集合练习-字符串长度排序 Map&lt;K,V&gt;集合 Map&lt;K,V&gt; 遍历 集合类的由来对象封装特有数据，对象多了，需要存储，如果对象的个数不确定就用集合容器进行存储。 集合的特点用于存储对象的容器。集合的长度是可以改变的。集合中不可以存储基本数据类型值。 集合框架图 Collection的共性方法 迭代器的使用12345678910public static void main()&#123; //使用Collection 中的iterator()方法 Collection coll = new ArrayList(); //Iterator it = coll.iterator(); //while(it.hasNext()&#123;System.out.println(it.next());&#125;//it浪费内存，改成for for(Iterator it = coll.iterator(); it.hasNext(); )&#123; System.out.println(it.next()); &#125;&#125; 有序重复同步问题Collection: |--List: 存取有序 可重复 有索引 |--Vector: 可增长的对象数组 同步 效率低 增长100%空间浪费 查询增删都慢 |--ArrayList: 可增长的对象数组 不同步 效率高，替代了Vector。增长50%空间浪费 查询快 |--LinkedList: 内部是链表数据结构 不同步 增删快 |--set: 不可重复 不同步 set接口中的方法和Collection一致 |--HashSet 内部数据结构是哈希表 无序 不同步 |--LinkedHashSet 存取有序 |--TreeSet 有字典排序 Map&lt;K,V&gt; 无序 |--Hashtable：内部结构 哈希表 同步 不支持空键空值 |--Properties：用来存储键值对型的配置文件的信息。可以IO技术相结合。 |--HashMap：内部结构 哈希表 不同步 支持空键空值 |--LinkedHashMap 存取有序 |--TreeMap：内部结构二叉树 不同步 List特有常见方法 list取出元素方法 通过迭代器取出 使用get()123for(int x = 0; x &lt; list.size(); x++)&#123; System.out.println(list.get(x));&#125; ListIterator介绍ListIterator是Iterator的子接口，因为iterator接口中只有，hasNext() next() remove()三个方法，所以并不能完成在集合操作中，继续操作iterator，否则会出现ConcurrentModificationException异常。使用方法：1234567891011121314//可以实现在迭代中完成对元素的增删改查，只有list有这个ListIterator it = list.listIterator();//获取列表迭代器对象white(it.hasNext())&#123; Object obj = it.next(); if(obj.equals("abc2"))&#123; it.add("abc9"); //it.set("abc9"); &#125;&#125;System.out.println("list:" + list);/**************************结果：list：[abc1,abc2,abc9,abc3]**************************/ 附录ListIterator主要方法 LinkedList ArrayList引用类型的集合1234567891011121314ArrayList a1 = new ArrayList();a1.add(new Person("lisi1",21));a1.add(new Person("lisi2",22));Iterator it = a1.iterator();while(it.hasNext())&#123; Person p = (Person) it.next(); System.out.println(p.getName()+"--"+p.getAge());&#125;/************结果：lisi1--21lisi2--22*************/ 哈希表确定元素是否相同1.判断的是两个元素的哈希值是否相同。如果如果相同，再判断两个对象的内容是否相同。2.判断哈希值相同，其实就是对象的hashCode方法。判断内容用的是equals注意：如果哈希值不同，是不需要判断内容的。 集合框架Collection练习定义功能去除ArrayList中的重复元素123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; ArrayList a1 = new ArrayList(); a1.add("acb1"); a1.add("acb2"); a1.add("acb1"); System.out.println(a1); a1 = getSingleElement(a1); System.out.println(a1); &#125; private static ArrayList getSingleElement(ArrayList a1) &#123; //1.定义一个临时容器 ArrayList temp = new ArrayList(); //2.迭代a1集合 Iterator it = a1.iterator(); while (it.hasNext()) &#123; Object obj = it.next(); //3.判断被迭代到的元素是否在临时容器中 if (!temp.contains(obj)) &#123; temp.add(obj); &#125; &#125; return temp; &#125;/**********结果:[acb1, acb2, acb1][acb1, acb2]*********/ 注意： 对于ArrayList来说，去重复自定义对象时，自定义的对象需要和 equals 方法，因为 contains 方法依据的还是equals方法 TreeSet中的比较TreeSet判断元素唯一的方法就是根据返回值是否是0，是0，就是元素相同，不存。 方法一 实现 Comparable 接口此接口强行对实现它的每个类的对象进行整体排序。这种排序称为类的自然排序,类的compareTo方法称为他的自然比较法1234567891011Person implements Comparable&lt;Person&gt;&#123;... @Override public int compareTo(Person p)&#123; /*以Person对象的年龄从小到大的顺序排*/ /*年龄相同，以字典顺序比较姓名*/ int temp = this.age-p.age; return temp == 0 ? this.name.compareTo(p.name) : temp; &#125;&#125; 方法二 构造一个比较器 Comparator如果不要按照对象中具备的自然顺序进行排序。如果对象中不具备自然顺序。比较器 Comparator 强行对某个对象collection进行整体排序。方法：int compare(T o1,T o2)boolean equals(Object obj)1234567891011public class ComparatorByName implements Comparator&lt;Person&gt; &#123; @Override public int compare(Person p1, Person p2) &#123; int temp = p1.getName().compareTo(p2.getName()); return temp == 0 ? p1.getAge() - p2.getAge() : temp; &#125;&#125; 使用：1TreeSet ts = new TreeSet(new ComparatorByName()); TreeSet集合练习-字符串长度排序123456789101112131415public class ComparatorByLength implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; String s1 = (String) o1; String s2 = (String) o2; int temp = s1.length() - s2.length(); return temp == 0 ? s1.compareTo(s2) : temp; &#125;&#125; Map&lt;K,V&gt;集合Map与Collection区别？Map一次添加一对数据，Collection一次添加一个元素Map的Key不能重复，Value可以重复常见方法： Map&lt;K,V&gt; 遍历方法一：KeySet（） 将键作为对象存储在set中123456789101112131415161718192021222324252627public static void main(String[] args) &#123; HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); method(map); &#125; public static void method(Map&lt;Integer,String&gt; map) &#123; map.put(1, "abc1"); map.put(2, "abc2"); map.put(5, "abc5"); map.put(7, "abc7"); Set&lt;Integer&gt; keySet = map.keySet(); Iterator&lt;Integer&gt; it = keySet.iterator(); while (it.hasNext()) &#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+":::"+value); &#125;&#125;/***********1:::abc12:::abc25:::abc57:::abc7***********/ 方法二：entrySet() 该方法将键和值的映射关系作为对象，存储到了Set集合中，而这个映射关系类型就是Map.Entry类型12345678910111213141516171819202122232425262728 public static void main(String[] args) &#123; HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); method(map); &#125; public static void method(Map&lt;Integer,String&gt; map) &#123; map.put(1, "abc1"); map.put(2, "abc2"); map.put(5, "abc5"); map.put(7, "abc7"); Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; next = it.next(); Integer key = next.getKey(); String value = next.getValue(); System.out.println(key+":::"+value); &#125;&#125;/***********1:::abc12:::abc25:::abc57:::abc7***********/ *集合使用选择技巧 集合需要唯一吗？ 需要：Set 需要制定顺序吗？ 需要：TreeSet 不需要：HashSet 想要一个和存储一致顺序：LinkedHashSet 不需要：List 需要频繁增删吗？ 需要：LinkedList 不需要：ArrayList 如何记录每一个容器的结构和所属体系呢？ 看名字！ List |--ArrayList |--LinkedList Set |--HashSet |--TreeSet 看到array 就要想到数组，就要想到查询快，有角标。 看到link 就要想到链表，就要想到增删快，就要想到 add get remove first last的方法 看到hash 就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode方法和equals方法。 看到tree 就要想到二叉树，就要想到要排序，就要想到两个接口`Comparable` `Comparator` 而且通常这些常见的集合容器是不同步的。 **泛型1.jdk1.5后出现的安全机制。2.将运行时期的问题ClassCastException 转到了编译时期。3.避免了强制转换的麻烦。&lt;&gt;:什么时候用？当操作的引用数据类型不确定的时候，就用&lt;&gt;.4.泛型技术是给编译器使用的技术，用于编译时期，确保了类型的安全。运行时，会去泛型，生成的class文件中是不带泛型的，这个称为泛型的擦除。为什么擦除？为了兼容运行的类加载器。5.泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不必强制转换类型。]]></content>
      <categories>
        <category>Java 集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事物的传播行为]]></title>
    <url>%2F2018%2F11%2F29%2FSpring-%E4%BA%8B%E7%89%A9%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[什么是事物的传播行为？ 当事务方法被另一个事务方法调用时, 必须指定事务应该如何传播. 例如: 方法可能继续在现有事务中运行, 也可能开启一个新事务, 并在自己的事务中运行 事务的传播行为可以由传播属性指定. Spring 定义了 7 种类传播行为： 这里比较重要的是前两个 REQUIRED 传播行为 当 bookService 的 purchase() 方法被另一个事务方法 checkout() 调用时, 它默认会在现有的事务内运行. 这个默认的传播行为就是REQUIRED. 因此在 checkout() 方法的开始和终止边界内只有一个事务. 这个事务只在 checkout() 方法结束的时候被提交, 结果用户一本书都买不了 事务传播属性可以在 @Transactional 注解的 propagation 属性中定义 REQUIRES_NEW 传播行为 另一种常见的传播行为是 REQUIRES_NEW. 它表示该方法必须启动一个新事务, 并在自己的事务内运行. 如果有事务在运行, 就应该先挂起它 注意：以上传播行为的类别是在@Transactional注解上配置propagation来完成的，如果没有配置默认情况是REQUIRED Spring中事务的定义：Propagation1.PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择 比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候， ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA 的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。 这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被 提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚 2.PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行 如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行 这就跟平常用的普通非事务的代码只有一点点区别了。不理这个，因为我也没有觉得有什么区别 3.PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常 必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常 4.PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起 这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW， 那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后， 他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在 两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚， 如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交 5.PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ， 那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务 6.PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常 不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ， 那么ServiceB.methodB就要抛出异常了 7.PROPAGATION_NESTED 理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立， 而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。 而Nested事务的好处是他有一个savepoint。 ServiceA { /** * 事务属性配置为 PROPAGATION_REQUIRED */ void methodA() { try { //savepoint ServiceB.methodB(); //PROPAGATION_NESTED 级别 } catch (SomeException) { // 执行其他业务, 如 ServiceC.methodC(); } } } 也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如 ServiceC.methodC，继续执行，来尝试完成自己的事务。但是这个事务并没有在EJB标准中定义]]></content>
      <categories>
        <category>Java 框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事物的隔离级别]]></title>
    <url>%2F2018%2F11%2F29%2FSpring-%E4%BA%8B%E7%89%A9%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Spring 事物隔离级别 @Transactional(isolation = Isolation.READ_UNCOMMITTED） 保证了读取过程中不会读取到非法数据 @Transactional(isolation = Isolation.READ_COMMITTED) 大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，该级别适用于大多数系统 @Transactional(isolation = Isolation.REPEATABLE_READ) 保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失 @Transactional(isolation = Isolation.SERIALIZABLE) 最严格的级别，事务串行执行，资源消耗最大 读取到非法数据的现象 Dirty reads — 读脏数据 也就是说，比如事务A的未提交（还依然缓存）的数据被事务B读走，如果事务A失败回滚，会导致事务B所读取的的数据是错误的 non-repeatable reads — 不可重复读 比如事务A中两处读取数据-total-的值。在第一读的时候，total是100，然后事务B就把total的数据改成200，事务A再读一次，结果就发现，total竟然就变成200了，造成事务A数据混乱 phantom reads — 幻象读数据 这个和non-repeatable reads相似，也是同一个事务中多次读不一致的问题。但是non-repeatable reads的不一致是因为他所要取的数据集被改变了（比如total的数据），但是phantom reads所要读的数据的不一致却不是他所要读的数据集改变，而是他的条件数据集改变。比如select account.id where account.name=’grace’,第一次读去了6个符合条件的id，第二次读取的时候，由于事务b把一个帐号的名字由”dd”改成”grace”，结果取出来了7个数据 不可重复读的重点是修改：同样的条件, 你读取过的数据, 再次读取出来发现值不一样了幻读的重点在于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样。 而事务的隔离级别会导致读取到非法数据的情况如下表示： 脏读 不可重复读 幻读 SERIALIZABLE 不会 不会 不会 REPEATABLE_READ 不会 不会 会 READ_COMMITTED 不会 会 会 READ_UNCOMMITTED 会 会 会 常用数据库默认事务隔离级别: MYSQL：默认为REPEATABLE_READ SQLSERVER：默认为READ_COMMITTED ORACLE：默认为READ_COMMITTED @Transactiona注解中常用参数说明 @Transactiona注解中常用参数说明 readOnly 该属性用于设置当前事务是否为只读事务，设置为true表示只读，false 则表示可读写，默认值为false。 例如：@Transactional(readOnly=true) rollbackFor 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。 例如： 指定单一异常类：@Transactional(rollbackFor=RuntimeException.class) 指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class}) rollbackForClassName 该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。 例如： 指定单一异常类名称：@Transactional(rollbackForClassName=”RuntimeException”) 指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”, “Exception”}) noRollbackFor 该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。类似上面的rollbackFor。 noRollbackForClassName 该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。类似上面的rollbackForClassName。 propagation 该属性用于设置事务的传播行为，具体取值可参考上文。 例如：@Transactional(propagation=Propagation.NOT_SUPPORTED, readOnly=true) isolation 该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置 timeout 该属性用于设置事务的超时秒数，默认值为 -1 表示永不超时 需要注意的几点: @Transactional 只能被应用到public方法上,对于其它非public的方法,如果标记了也不会报错,但方法没有事务功能 Spring 团队的建议是你在具体的类（或类的方法）上使用@Transactional注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用@Transactional注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装 使用 Spring 事务管理器,由它来负责数据库的打开、提交、回滚]]></content>
      <categories>
        <category>Java 框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
